

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Transport Layer Security (TLS) Lab &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Hardware Labs" href="../hardware/hardware_index.html" />
    <link rel="prev" title="RSA Public-Key Encryption and Signature Lab" href="rsa.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="crypto_index.html">Cryptography Labs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="encryption.html">Secret-Key Encryption Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="hash_length_ext.html">Hash Length Extension Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="md5_collision.html">MD5 Collision Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="padding_oracle.html">Padding Oracle Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="pki.html">Public-Key Infrastructure (PKI) Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="random_number.html">Pseudo Random Number Generation Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="rsa.html">RSA Public-Key Encryption and Signature Lab</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Transport Layer Security (TLS) Lab</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">Lab Environment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-1-tls-client">Task 1: TLS Client</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-2-tls-server">Task 2: TLS Server</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-3-a-simple-https-proxy">Task 3: A Simple HTTPS Proxy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/hardware_index.html">Hardware Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/network_index.html">Network Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../software/software_index.html">Software Security Labs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../website_link/web_index.html"><strong>Return To Website</strong></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="crypto_index.html">Cryptography Labs</a> &raquo;</li>
        
      <li>Transport Layer Security (TLS) Lab</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="center docutils container">
Transport Layer Security (TLS) Lab</div>
<div class="section" id="transport-layer-security-tls-lab">
<h1>Transport Layer Security (TLS) Lab<a class="headerlink" href="#transport-layer-security-tls-lab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Nowadays more and more data transmissions are done through the Internet.
However, when data are transmitted over such a public network
unprotected, they can be read or even modified by others. Applications
worrying about the security of their communication need to encrypt their
data and detect tampering. Cryptographic solutions can be used to
achieve this goal. There are many cryptographic algorithms, and even for
the same algorithm, there are many parameters that can be used. To
achieve interoperability, i.e., allowing different applications to
communicate with one another, these applications need to follow a common
standard. TLS, Transport Layer Security, is such a standard. Most web
servers these days are using HTTPS, which is built on top of TLS.</p>
<p>The objective of this lab is to help students understand how the TLS
works and how to use TLS in programming. The lab guides students to
implement a pair of TLS client and server programs, based on which
students will conduct a series of experiments, so they can understand
the security principles underlying the TLS protocol. Students will also
implement a simple HTTPS proxy program to understand the security impact
if some trusted CAs are compromised. The lab covers the following
topics:</p>
<ul class="simple">
<li>Public-Key Infrastructure (PKI)</li>
<li>Transport Layer Security (TLS)</li>
<li>TLS programming</li>
<li>HTTPS proxy</li>
<li>X.509 certificates with the Subject Alternative Name (SAN) extensions</li>
<li>Man-In-The-Middle attacks</li>
</ul>
<div class="section" id="prerequisite">
<h3>Prerequisite.<a class="headerlink" href="#prerequisite" title="Permalink to this headline">¶</a></h3>
<p>This lab depends on the PKI lab. Students should do the PKI lab before
working on this lab.</p>
</div>
<div class="section" id="readings">
<h3>Readings.<a class="headerlink" href="#readings" title="Permalink to this headline">¶</a></h3>
<p>Detailed coverage of PKI and TLS can be found in the following:</p>
<ul class="simple">
<li>Chapters 24 and 25 of the SEED Book, <em>Computer &amp; Internet Security: A
Hands-on Approach</em>, 2nd Edition, by Wenliang Du. See details at
<a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</li>
</ul>
</div>
<div class="section" id="lab-environment">
<h3>Lab Environment.<a class="headerlink" href="#lab-environment" title="Permalink to this headline">¶</a></h3>
<p>This lab has been tested on the SEED Ubuntu 20.04 VM. You can download a
pre-built image from the SEED website, and run the SEED VM on your own
computer. However, most of the SEED labs can be conducted on the cloud,
and you can follow our instruction to create a SEED VM on the cloud.</p>
</div>
</div>
<div class="section" id="id1">
<h2>Lab Environment<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>In this lab, we use three machines, one for client, one for server, and
the other for proxy. We will use containers for these machines. Their IP
addresses are listed in the following:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>client: 10.9.0.5
server: 10.9.0.43
proxy:  10.9.0.143
</pre></div>
</div>
<div class="section" id="container-setup-and-commands">
<h3>Container Setup and Commands.<a class="headerlink" href="#container-setup-and-commands" title="Permalink to this headline">¶</a></h3>
<p>Please download the <code class="docutils literal notranslate"><span class="pre">Labsetup.zip</span></code> file to your VM from the lab’s
website, unzip it, enter the <code class="docutils literal notranslate"><span class="pre">Labsetup</span></code> folder, and use the
<code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file to set up the lab environment. Detailed
explanation of the content in this file and all the involved
<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> can be found from the user manual, which is linked to the
website of this lab. If this is the first time you set up a SEED lab
environment using containers, it is very important that you read the
user manual.</p>
<p>In the following, we list some of the commonly used commands related to
Docker and Compose. Since we are going to use these commands very
frequently, we have created aliases for them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file (in
our provided SEEDUbuntu 20.04 VM).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker-compose build  # Build the container image
$ docker-compose up     # Start the container
$ docker-compose down   # Shut down the container

// Aliases for the Compose commands above
$ dcbuild       # Alias for: docker-compose build
$ dcup          # Alias for: docker-compose up
$ dcdown        # Alias for: docker-compose down
</pre></div>
</div>
<p>All the containers will be running in the background. To run commands on
a container, we often need to get a shell on that container. We first
need to use the <code class="docutils literal notranslate"><span class="pre">&quot;docker</span> <span class="pre">ps&quot;</span></code> command to find out the ID of the
container, and then use <code class="docutils literal notranslate"><span class="pre">&quot;docker</span> <span class="pre">exec&quot;</span></code> to start a shell on that
container. We have created aliases for them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dockps        // Alias for: docker ps --format &quot;{{.ID}}  {{.Names}}&quot;
$ docksh &lt;id&gt;   // Alias for: docker exec -it &lt;id&gt; /bin/bash

// The following example shows how to get a shell inside hostC
$ dockps
b1004832e275  hostA-10.9.0.5
0af4ea7a3e2e  hostB-10.9.0.6
9652715c8e0a  hostC-10.9.0.7

$ docksh 96
root@9652715c8e0a:/#

// Note: If a docker command requires a container ID, you do not need to
//       type the entire ID string. Typing the first few characters will
//       be sufficient, as long as they are unique among all the containers.
</pre></div>
</div>
<p>If you encounter problems when setting up the lab environment, please
read the “Common Problems” section of the manual for potential
solutions.</p>
</div>
<div class="section" id="volumes">
<h3>Volumes.<a class="headerlink" href="#volumes" title="Permalink to this headline">¶</a></h3>
<p>Code editing is more convenient inside the VM than in containers,
because we can use our favorite editors. In order for the VM and
container to share files, we have created a shared folder between the VM
and the container using the Docker <code class="docutils literal notranslate"><span class="pre">volumes</span></code>. If you look at the
Docker Compose file, you will find out that we have added the following
entry to some of the containers. It indicates mounting the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code>
folder on the host machine (i.e., the VM) to the <code class="docutils literal notranslate"><span class="pre">/volumes</span></code> folder
inside the container. We will write our code in the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code> folder
(on the VM), so they can be used inside the containers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>volumes:
       - ./volumes:/volumes
</pre></div>
</div>
</div>
</div>
<div class="section" id="task-1-tls-client">
<h2>Task 1: TLS Client<a class="headerlink" href="#task-1-tls-client" title="Permalink to this headline">¶</a></h2>
<p>In this task, we will incrementally build a simple TLS client program.
Through the process, students will understand the essential elements and
security considerations in TLS programming. We will run this client
program on the client container.</p>
<div class="section" id="task-1-a-tls-handshake">
<h3>Task 1.a: TLS handshake<a class="headerlink" href="#task-1-a-tls-handshake" title="Permalink to this headline">¶</a></h3>
<p>Before a client and a server can communicate securely, several things
need to be set up first, including what encryption algorithm and key
will be used, what MAC algorithm will be used, what algorithm should be
used for the key exchange, etc. These cryptographic parameters need to
be agreed upon by the client and the server. That is the primary purpose
of the TLS Handshake Protocol. In this task, we focus on the TLS
handshake protocol. The following sample code initiates a TLS handshake
with a TLS server (the name of the server needs to be specified as the
first command line argument).</p>
<div class="code python highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python3

import socket, ssl, sys, pprint

hostname = sys.argv[1]
port = 443
cadir = &#39;/etc/ssl/certs&#39;

# Set up the TLS context
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
context.load_verify_locations(capath=cadir)
context.verify_mode = ssl.CERT_REQUIRED
context.check_hostname = True

# Create TCP connection
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((hostname, port))
input(&quot;After making TCP connection. Press any key to continue ...&quot;)

# Add the TLS
ssock = context.wrap_socket(sock, server_hostname=hostname,
                            do_handshake_on_connect=False)
ssock.do_handshake()   # Start the handshake
pprint.pprint(ssock.getpeercert())
input(&quot;After handshake. Press any key to continue ...&quot;)

# Close the TLS Connection
ssock.shutdown(socket.SHUT_RDWR)
ssock.close()
</pre></div>
</div>
<div class="section" id="tasks">
<h4>Tasks.<a class="headerlink" href="#tasks" title="Permalink to this headline">¶</a></h4>
<p>Use the code above to communicate with a real HTTPS-based web server.
Additional code may need to be added to complete the tasks. Students can
find the manual for Python’s SSL module online. Please report the
following:</p>
<ul class="simple">
<li>What is the cipher used between the client and the server?</li>
<li>Please print out the server certificate in the program.</li>
<li>Explain the purpose of <code class="docutils literal notranslate"><span class="pre">/etc/ssl/certs</span></code>.</li>
<li>Use Wireshark to capture the network traffics during the execution of
the program, and explain your observation. In particular, explain
which step triggers the TCP handshake, and which step triggers the
TLS handshake. Explain the relationship between the TLS handshake and
the TCP handshake.</li>
</ul>
</div>
</div>
<div class="section" id="task-1-b-cas-certificate">
<h3>Task 1.b: CA’s Certificate<a class="headerlink" href="#task-1-b-cas-certificate" title="Permalink to this headline">¶</a></h3>
<p>In the previous task, we use the certificates in the <code class="docutils literal notranslate"><span class="pre">/etc/ssl/certs</span></code>
folder to verify server’s certificates. In this task, we will create our
own certificate folder, and place the corresponding certificates in the
folder to do the verification.</p>
<p>Please create a folder called <code class="docutils literal notranslate"><span class="pre">client-certs</span></code>, and change the <code class="docutils literal notranslate"><span class="pre">cadir</span></code>
line in the client program to the following. Run the client program and
report your observation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cadir = &#39;./client-certs&#39;
</pre></div>
</div>
<p>To solve this problem, you need to place the corresponding CA’s
certificate into your <code class="docutils literal notranslate"><span class="pre">client-certs</span></code> folder. Please use your client
program to find out what CA certificate is needed to verify the
<code class="docutils literal notranslate"><span class="pre">www.example.com</span></code> server’s certificate, and then copy the certificate
from the <code class="docutils literal notranslate"><span class="pre">/etc/ssl/certs</span></code> to your own folder. Run your client program
again. If you have done everything correctly, your client program should
be able to talk to the server.</p>
<p>It should be noted that copying CA’s certificate to the
<code class="docutils literal notranslate"><span class="pre">&quot;./client-certs&quot;</span></code> folder is not enough. When TLS tries to verify a
server certificate, it will generate a hash value from the issuer’s
identify information, use this hash value as part of the file name, and
then use this name to find the issuer’s certificate in the
<code class="docutils literal notranslate"><span class="pre">&quot;./client-certs&quot;</span></code> folder. Therefore, we need to rename each CA’s
certificate using the hash value generated from its subject field, or we
can make a symbolic link out of the hash value. In the following
command, we use <code class="docutils literal notranslate"><span class="pre">openssl</span></code>to generate a hash value, which is then
used to create a symbolic link.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ openssl x509 -in someCA.crt -noout -subject_hash
(*@\textbf{4a6481c9}@*)

$ ln -s someCA.crt (*@\textbf{4a6481c9.0}@*)
$ ls -l
total 4
lrwxrwxrwx 1 ... 4a6481c9.0 -&gt; someCA.crt
-rw-r--r-- 1 ... someCA.crt
</pre></div>
</div>
<div class="section" id="additional-requirement">
<h4>Additional requirement:<a class="headerlink" href="#additional-requirement" title="Permalink to this headline">¶</a></h4>
<p>Please conduct this task for two different web servers that use
different CA certificates.</p>
</div>
</div>
<div class="section" id="task-1-c-experiment-with-the-hostname-check">
<h3>Task 1.c: Experiment with the hostname check<a class="headerlink" href="#task-1-c-experiment-with-the-hostname-check" title="Permalink to this headline">¶</a></h3>
<p>The objective of this task is to help students understand the importance
of hostname checks at the client side. Please conduct the following
steps using the client program.</p>
<ul>
<li><p class="first">Step 1: Get the IP address of <code class="docutils literal notranslate"><span class="pre">www.example.com</span></code> using the <code class="docutils literal notranslate"><span class="pre">dig</span></code>
command, such as the following (you may want to run this command in
your VM or host computers, because the <code class="docutils literal notranslate"><span class="pre">dig</span></code> command is not
installed inside the container):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dig www.example.com
...
;; ANSWER SECTION:
www.example.com.    403 IN  A   93.184.216.34
</pre></div>
</div>
</li>
<li><p class="first">Step 2: Modify the <code class="docutils literal notranslate"><span class="pre">/etc/hosts</span></code> file (inside the container), add
the following entry at the end of the file (the IP address is what
you get from the <code class="docutils literal notranslate"><span class="pre">dig</span></code> command).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>93.184.216.34   www.example2020.com
</pre></div>
</div>
</li>
<li><p class="first">Step 3: Switch the following line in the client program between
<code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code>, and then connect your client program to
<code class="docutils literal notranslate"><span class="pre">www.example2020.com</span></code>. Describe and explain your observation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>context.check_hostname = False  # try both True and False
</pre></div>
</div>
</li>
</ul>
<div class="section" id="the-importance-of-hostname-check">
<h4>The importance of hostname check:<a class="headerlink" href="#the-importance-of-hostname-check" title="Permalink to this headline">¶</a></h4>
<p>Based on this experiment, please explain the importance of hostname
check. If the client program does not perform the hostname check, what
is the security consequence? Please explain.</p>
</div>
</div>
<div class="section" id="task-1-d-sending-and-getting-data">
<h3>Task 1.d: Sending and getting Data<a class="headerlink" href="#task-1-d-sending-and-getting-data" title="Permalink to this headline">¶</a></h3>
<p>In this task, we will send data to the server and get its response.
Since we choose to use HTTPS servers, we need to send HTTP requests to
the server; otherwise, the server will not understand our request. The
following code example shows how to send HTTP requests and how to read
the response.</p>
<div class="code python highlight-none notranslate"><div class="highlight"><pre><span></span># Send HTTP Request to Server
request = b&quot;GET / HTTP/1.0\r\nHost: &quot; + \
          hostname.encode(&#39;utf-8&#39;) + b&quot;\r\n\r\n&quot;
ssock.sendall(request)

# Read HTTP Response from Server
response = ssock.recv(2048)
while response:
  pprint.pprint(response.split(b&quot;\r\n&quot;))
  response = ssock.recv(2048)
</pre></div>
</div>
<div class="section" id="tasks-1">
<span id="id2"></span><h4>Tasks.<a class="headerlink" href="#tasks-1" title="Permalink to this headline">¶</a></h4>
<p>(1) Please add the data sending/receiving code to your client program,
and report your observation. (2) Please modify the HTTP request, so you
can fetch an image file of your choice from an HTTPS server (there is no
need to display the image).</p>
</div>
</div>
</div>
<div class="section" id="task-2-tls-server">
<h2>Task 2: TLS Server<a class="headerlink" href="#task-2-tls-server" title="Permalink to this headline">¶</a></h2>
<p>Before working on this task, students need to create a certificate
authority (CA), and use this CA’s private key to create a server
certificate for this task. How to do these is already covered in another
SEED lab (the PKI lab), which is the prerequisite for this lab. In this
task, we assume that all the required certificates have already been
created, including CA’s public-key certificate and private key
(<code class="docutils literal notranslate"><span class="pre">ca.crt</span></code> and <code class="docutils literal notranslate"><span class="pre">ca.key</span></code>), and the server’s public-key certificate and
private key (<code class="docutils literal notranslate"><span class="pre">server.crt</span></code> and <code class="docutils literal notranslate"><span class="pre">server.key</span></code>). It should be noted that
the common name used in the server certificate must contain the
student’s last name and the current year.</p>
<p>We will use the server container to run this TLS server program. Make
sure you set up the DNS mapping accordingly, so the name of your TLS
server points to the IP address of the server container.</p>
<div class="section" id="task-2-a-implement-a-simple-tls-server">
<h3>Task 2.a. Implement a simple TLS server<a class="headerlink" href="#task-2-a-implement-a-simple-tls-server" title="Permalink to this headline">¶</a></h3>
<p>In this task, we will implement a simple TLS server. We will use the
client program from Task 1 to test this server program. A sample server
code is provided in the following.</p>
<div class="code python highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env python3

import socket
import ssl

html = &quot;&quot;&quot;
HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
&quot;&quot;&quot;

SERVER_CERT    = &#39;./server-certs/server.crt&#39;
SERVER_PRIVATE = &#39;./server-certs/server.key&#39;


context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain(SERVER_CERT, SERVER_PRIVATE)

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
sock.bind((&#39;0.0.0.0&#39;, 443))
sock.listen(5)

while True:
   newsock, fromaddr = sock.accept()
   ssock = context.wrap_socket(newsock, server_side=True)

   data = ssock.recv(1024)              # Read data over TLS
   ssock.sendall(html.encode(&#39;utf-8&#39;))  # Send data over TLS

   ssock.shutdown(socket.SHUT_RDWR)     # Close the TLS connection
   ssock.close()
</pre></div>
</div>
<div class="section" id="testing">
<h4>Testing.<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h4>
<p>We will use the client program developed in Task 1 to test this server
program. In Task 1, the client program loads the trusted certificates
from the folder. In this task, the CA is created by us, and its
certificate is not stored in that folder. We do not recommend students
to add this CA to that folder, because that will affect the entire
system. Students should store the CA’s certificate in the
<code class="docutils literal notranslate"><span class="pre">&quot;./client-certs&quot;</span></code> folder, and then follow the instruction in Task 1
to set up the folder. Please test your program using the folder and the
<code class="docutils literal notranslate"><span class="pre">./client-certs</span></code> folder, respectively. Please describe your
observation and explain why.</p>
</div>
</div>
<div class="section" id="task-2-b-testing-the-server-program-using-browsers">
<h3>Task 2.b. Testing the server program using browsers<a class="headerlink" href="#task-2-b-testing-the-server-program-using-browsers" title="Permalink to this headline">¶</a></h3>
<p>In this task, we will test our TLS server program using the browser on
the host VM. First, point your browser to the server, report what you
see from the browser and explain why. The server listens to port
<code class="docutils literal notranslate"><span class="pre">443</span></code>, which is the default port for HTTPS.</p>
<p>In order for browsers to communicate with your TLS server, the browser
needs to verify your server’s certificate. It has to use the certificate
issuer CA’s certificate to do the verification, but since this CA is
created in our lab, the browser does not have it on its trusted
certificate list. We need to manually add our CA’s certificate to it. To
do that, type the following URL in the address bar, and click the
<code class="docutils literal notranslate"><span class="pre">View</span> <span class="pre">Certificates</span></code> button on the page (scroll to the bottom).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>about:preferences#privacy
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">Authorities</span></code> tab, you will see a list of certificates that are
already accepted by Firefox. From here, we can import our own
certificates. After choosing the certificate file, please select the
following option: “Trust this CA to identify web sites”. You will see
that our certificate is now in Firefox’s list of accepted certificates.</p>
<p>Please demonstrate that your browser can successfully communicate with
your TLS server, and can display the content returned by the server.</p>
</div>
<div class="section" id="task-2-c-certificate-with-multiple-names">
<h3>Task 2.c. Certificate with multiple names<a class="headerlink" href="#task-2-c-certificate-with-multiple-names" title="Permalink to this headline">¶</a></h3>
<p>Many websites have different URLs. For example,
<a class="reference external" href="www.example.com">www.example.com</a>,
<a class="reference external" href="www.example.org">www.example.org</a>, <a class="reference external" href="example.com">example.com</a> all
point to the same web server. Due to the hostname matching policy
enforced by most TLS client programs, the common name in a certificate
must match with the server’s hostname, or TLS clients will refuse to
communicate with the server.</p>
<p>To allow a certificate to have multiple names, the X.509 specification
defines extensions to be attached to a certificate. This extension is
called Subject Alternative Name (SAN). Using the SAN extension, it’s
possible to specify several hostnames in the <code class="docutils literal notranslate"><span class="pre">subjectAltName</span></code> field of
a certificate.</p>
<p>To generate a certificate signing request with such a field, we can use
a configuration file, and put all the necessary information in this file
(the PKI lab shows how you can do everything in the command line). The
following configuration file gives an example. It specifies the content
for the subject field and add a <code class="docutils literal notranslate"><span class="pre">subjectAltName</span></code> field in the
extension. The field specifies several alternative names, including a
wildcard name <code class="docutils literal notranslate"><span class="pre">*.bank32.com</span></code>. It should be noted that the field must
also include the one from the common name field; otherwise, the common
name will not be accepted as a valid name.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[ req ]
prompt             = no
distinguished_name = req_distinguished_name
req_extensions     = req_ext

[ req_distinguished_name ]
C  = US
ST = New York
L  = Syracuse
O  = XYZ LTD.
CN = www.bank32.com

[ req_ext ]
subjectAltName = @alt_names

[alt_names]
DNS.1   = www.bank32.com
DNS.2   = www.example.com
DNS.3   = *.bank32.com
</pre></div>
</div>
<p>We can use the following <code class="docutils literal notranslate"><span class="pre">&quot;openssl</span> <span class="pre">req&quot;</span></code> command to generate a pair of
public/private keys and a certificate signing request:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>openssl req -newkey rsa:2048 -config ./server_openssl.cnf -batch \
            -sha256 -keyout server.key -out server.csr
</pre></div>
</div>
<p>When the CA signs a certificate, for the security reason, by default, it
does not copy the extension field from the certificate signing request
into the final certificate. In order to allow the copying, we need to
change the <code class="docutils literal notranslate"><span class="pre">openssl</span></code>’s configuration file. By default, <code class="docutils literal notranslate"><span class="pre">openssl</span></code>
uses the configuration file <code class="docutils literal notranslate"><span class="pre">openssl.cnf</span></code> from the directory. Inside
this file, the <code class="docutils literal notranslate"><span class="pre">copy_extensions</span></code> option is disabled (commented out).
We do not want to modify this system-wide configuration file. Let us
copy it file to our own folder, and rename it as <code class="docutils literal notranslate"><span class="pre">myopenssl.cnf</span></code>. We
then uncomment the following line from this file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Extension copying option: use with caution.
copy_extensions = copy
</pre></div>
</div>
<p>Now, we can use the following program to generate the certificate
(<code class="docutils literal notranslate"><span class="pre">server.crt</span></code>) for the server from the certificate signing request
(<code class="docutils literal notranslate"><span class="pre">server.csr</span></code>), and all the extension fields from the request will be
copied to the final certificate.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>openssl ca -md sha256 -days 3650 -config ./myopenssl.cnf -batch \
           -in server.csr -out server.crt \
           -cert ca.crt -keyfile ca.key
</pre></div>
</div>
<p>Students need to demonstrate that their server can support multiple
hostnames, including any hostname in their respective domains.</p>
</div>
</div>
<div class="section" id="task-3-a-simple-https-proxy">
<h2>Task 3: A Simple HTTPS Proxy<a class="headerlink" href="#task-3-a-simple-https-proxy" title="Permalink to this headline">¶</a></h2>
<p>TLS can protect against the Man-In-The-Middle attack, but only if the
underlying public-key infrastructure is secured. In this task, we will
demonstrate the Man-In-The-Middle attack against TLS servers if the PKI
infrastructure is compromised, i.e., some trusted CA is compromised or
the server’s private key is stolen.</p>
<p>We will implement a simple HTTPS proxy called <code class="docutils literal notranslate"><span class="pre">mHTTPSproxy</span></code> (<code class="docutils literal notranslate"><span class="pre">m</span></code>
stands for <code class="docutils literal notranslate"><span class="pre">mini</span></code>). The proxy program simply integrates the client and
server programs from Task 1 and 2 together. How it works is illustrated
in <strong>Figure&nbsp;1</strong>. We will run the proxy on the proxy
container.</p>
<div class="center docutils container">
<div class="align-center figure" id="id3">
<img alt="How ``mHTTPSproxy`` works" src="../../_images/httpsproxy.jpg" />
<p class="caption"><span class="caption-text">Figure 1: How <code class="docutils literal notranslate"><span class="pre">mHTTPSproxy</span></code> works</span></p>
</div>
</div>
<p>The proxy is actually a combination of the TLS client and server
programs. To the browser, the TLS proxy is just a server program, which
takes the HTTP requests from the browser (the client), and return HTTP
responses to it. The proxy does not generate any HTTP responses;
instead, it forwards the HTTP requests to the actual web server, and
then get the HTTP responses from the web server. To the actual web
server, the TLS proxy is just a client program. After getting the
response, the proxy forwards the response to the browser, the real
client. Therefore, by integrating the client and server programs
implemented in the previous two tasks, students should be able to get a
basic proxy working.</p>
<p>It should be noted that the purpose of this task is to use this simple
proxy to understand how the Man-In-The-Middle attack works when the PKI
infrastructure is compromised. It is not intended to implement a
product-quality HTTPS proxy, because making the proxy work for every web
server is not an easy job, as many aspects of the HTTP protocol need to
be considered. Since the focus of this lab is on TLS, students can
choose two different servers, and demonstrate that their proxy works for
those servers. Students who are interested in product-quality HTTPS
proxy, can find that from the Internet, such as the open-source
<code class="docutils literal notranslate"><span class="pre">mitmproxy</span></code>.</p>
<div class="section" id="handling-multiple-http-requests">
<h3>Handling multiple HTTP requests.<a class="headerlink" href="#handling-multiple-http-requests" title="Permalink to this headline">¶</a></h3>
<p>A browser may simultaneously send multiple HTTP requests to the server,
so after receiving an HTTP request from the browser, it is better to
spawn a thread to process that request, so the proxy program can handle
multiple simultaneous requests. The following code snippet shows how to
create a thread to handle each TLS connection.</p>
<div class="code python highlight-none notranslate"><div class="highlight"><pre><span></span>import threading

while True:
    sock_for_browser, fromaddr = sock_listen.accept()
    ssock_for_browser = context_srv.wrap_socket(sock_for_browser,
                                                server_side=True)
    x = threading.Thread(target=process_request, args=(ssock_for_browser,))
    x.start()
</pre></div>
</div>
<p>The thread will execute the code in the <code class="docutils literal notranslate"><span class="pre">process_request</span></code> function,
which forwards the HTTP request from the browser to the server, and then
forward the HTTP response from the server to the browser. A code
skeleton is provided in the following:</p>
<div class="code python highlight-none notranslate"><div class="highlight"><pre><span></span>def process_request(ssock_for_browser):
    hostname = &#39;www.example.com&#39;

    # Make a connection to the real server
    sock_for_server  = socket.create_connection((hostname, 443))
    ssock_for_server = ... # [Code omitted]: Wrap the socket using TLS

    request = ssock_for_browser.recv(2048)

    if request:
        # Forward request to server
        ssock_for_server.sendall(request)

        # Get response from server, and forward it to browser
        response = ssock_for_server.recv(2048)
        while response:
            ssock_for_browser.sendall(response) # Forward to browser
            response = ssock_for_server.recv(2048)

    ssock_for_browser.shutdown(socket.SHUT_RDWR)
    ssock_for_browser.close()
</pre></div>
</div>
</div>
<div class="section" id="the-client-setup">
<h3>The client setup.<a class="headerlink" href="#the-client-setup" title="Permalink to this headline">¶</a></h3>
<p>For this task, since we will use a browser, we will use the hosting VM
as the client/victim, instead of using the client container. In the
real-world attack, when the victim tries to visit a web server (say
<code class="docutils literal notranslate"><span class="pre">www.example.com</span></code>), we will launch attacks to redirect the victim to
our proxy. This is usually done by DNS attacks, BGP attacks, or other
redirection attacks. We will not actually do such attacks. We simply add
the following entry to the <code class="docutils literal notranslate"><span class="pre">/etc/hosts</span></code> file on the host VM
(<code class="docutils literal notranslate"><span class="pre">10.9.0.143</span></code> is the IP address of the mitm-proxy container in our
setup).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>10.9.0.143   www.example.com
</pre></div>
</div>
<p>By doing the above, we simulate the result of redirection attacks: the
victim’s traffic to the web server <code class="docutils literal notranslate"><span class="pre">www.example.com</span></code> will be
redirected to the attacker’s machine, where your <code class="docutils literal notranslate"><span class="pre">mHTTPSproxy</span></code> is
waiting for HTTP requests.</p>
</div>
<div class="section" id="the-proxy-setup">
<h3>The proxy setup.<a class="headerlink" href="#the-proxy-setup" title="Permalink to this headline">¶</a></h3>
<p>It should be noted that changes on the VM’s <code class="docutils literal notranslate"><span class="pre">/etc/hosts</span></code> file will
affect all the containers, because containers uses Docker’s embedded DNS
server, which forwards external DNS lookups to the DNS servers
configured on the host (i.e., the VM), and the host’s DNS server do use
the <code class="docutils literal notranslate"><span class="pre">/etc/hosts</span></code> file. Therefore, due to the change above, on the
proxy container, the IP address to <code class="docutils literal notranslate"><span class="pre">www.example.com</span></code> is also mapped to
<code class="docutils literal notranslate"><span class="pre">10.9.0.143</span></code>. This is a problem, because the proxy needs to
communicate with the actual web server.</p>
<p>To do so, we can ask the container to use an external DNS server,
instead of using its built-in one. This can be done by manually changing
the <code class="docutils literal notranslate"><span class="pre">/etc/resolv.conf</span></code> file on the proxy container (not the one on the
VM). The file has one or multiple <code class="docutils literal notranslate"><span class="pre">nameserver</span></code> entry. Change the first
one to <code class="docutils literal notranslate"><span class="pre">8.8.8.8</span></code>, which is the public DNS server provided by Google.
You can also use other public DNS servers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nameserver 8.8.8.8
</pre></div>
</div>
<p>A more permanent way to solve this problem is to add the following DNS
entry to the <code class="docutils literal notranslate"><span class="pre">MITM-Proxy</span></code>’s configuration in the
<code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file. This entry tells the container’s built-in
DNS server to forward DNS requests to <code class="docutils literal notranslate"><span class="pre">8.8.8.8</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dns:
    - 8.8.8.8
</pre></div>
</div>
<p>After making the change, please go to the proxy container, ping
<code class="docutils literal notranslate"><span class="pre">www.example.com</span></code>. Make sure the responses come from the real web
server, not from <code class="docutils literal notranslate"><span class="pre">10.9.0.143</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ping www.example.com
PING www.example.com (93.184.216.34) 56(84) bytes of data.
64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=1 ...
64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=2 ...
</pre></div>
</div>
<div class="section" id="task">
<h4>Task.<a class="headerlink" href="#task" title="Permalink to this headline">¶</a></h4>
<p>Students should implement the simple <code class="docutils literal notranslate"><span class="pre">mHTTPSproxy</span></code>, and run it on the
proxy container. In this MITM attack, we assume that the attacker has
compromised a trusted CA, and is able to use the CA’s private key to
generate fake (but valid) certificates for any domain name. In this lab,
the CA certificate generated in Task 2 is already trusted by the
browser, and we assume this CA’s private key is compromised, so
you/attacker can use it to forge certificate for any web server. Please
demonstrate your MITM attack in the following scenarios:</p>
<ul class="simple">
<li>Launch the MITM attack against your own server.</li>
<li>Launch the MITM attack on a real HTTPS website. You can pick a
website. Find one that requires login, and then use your MITM proxy
to steal the password. Many popular servers, such as facebook, have
complicated login mechanisms, so feel free to find a server that has
simple login mechanisms. Please remember to hide your password in
your lab report if you are using a real password.</li>
</ul>
</div>
</div>
<div class="section" id="cleanup">
<h3>Cleanup.<a class="headerlink" href="#cleanup" title="Permalink to this headline">¶</a></h3>
<p>After finishing this task, please remember to remove the CA’s
certificate from your browser, and also remove any entry that you have
added to <code class="docutils literal notranslate"><span class="pre">/etc/hosts</span></code> on your VM.</p>
</div>
</div>
<div class="section" id="submission">
<h2>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h2>
<p>You need to submit a detailed lab report, with screenshots, to describe
what you have done and what you have observed. You also need to provide
explanation to the observations that are interesting or surprising.
Please also list the important code snippets followed by explanation.
Simply attaching code without any explanation will not receive credits.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../hardware/hardware_index.html" class="btn btn-neutral float-right" title="Hardware Labs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="rsa.html" class="btn btn-neutral float-left" title="RSA Public-Key Encryption and Signature Lab" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>