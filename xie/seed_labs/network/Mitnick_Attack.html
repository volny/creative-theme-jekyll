

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>The Mitnick Attack Lab &mdash; Network Security Lab  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Packet Sniffing and Spoofing Lab" href="Sniffing_Spoofing.html" />
    <link rel="prev" title="ICMP Redirect Attack Lab" href="ICMP_Redirect.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Network Security Lab
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../xie/xie_labs.html">Xie Labs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../seed_index.html">SEED Labs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../crypto/crypto_index.html">Cryptography Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hardware/hardware_index.html">Hardware Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mobile/mobile_index.html">Mobile Security Labs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="network_index.html">Network Security Labs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="arp_attack.html">ARP Cache Poisoning Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="bgp_basic.html">BGP Lab: Building an Internet Simulator</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_in_a_box.html">DNS In a Box</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_local.html">Local DNS Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_rebinding.html">DNS Rebinding Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns_remote.html">The Kaminsky Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="dnssec.html">DNS Security Extensions (DNSSEC) Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall.html">Firewall Exploration Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="firewall_vpn.html">Firewall Evasion Lab: Bypassing Firewalls using VPN</a></li>
<li class="toctree-l3"><a class="reference internal" href="Heartbleed.html">Heartbleed Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="ICMP_Redirect.html">ICMP Redirect Attack Lab</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">The Mitnick Attack Lab</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-the-mitnick-attack-works">How the Mitnick Attack Works</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lab-environment-setup-using-container">Lab Environment Setup Using Container</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-1-simulated-syn-flooding">Task 1: Simulated SYN flooding</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-2-spoof-tcp-connections-and-rsh-sessions">Task 2: Spoof TCP Connections and <code class="docutils literal notranslate"><span class="pre">rsh</span></code> Sessions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-3-set-up-a-backdoor">Task 3: Set Up a Backdoor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Sniffing_Spoofing.html">Packet Sniffing and Spoofing Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="TCP_Attacks.html">TCP/IP Attack Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="VPN.html">Virtual Private Network (VPN) Lab</a></li>
<li class="toctree-l3"><a class="reference internal" href="VPN_Tunnel.html">VPN Lab: The Container Version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../web/web_index.html">Web Security Labs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../software/software_index.html">Software Security Labs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../website_link/web_index.html"><strong>Return To Website</strong></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Network Security Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../seed_index.html">SEED Labs</a> &raquo;</li>
        
          <li><a href="network_index.html">Network Security Labs</a> &raquo;</li>
        
      <li>The Mitnick Attack Lab</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-mitnick-attack-lab">
<h1>The Mitnick Attack Lab<a class="headerlink" href="#the-mitnick-attack-lab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Kevin Mitnick is probably one of the most well-known hackers in USA. He
was on FBI’s wanted list of criminals. While on the run, he became
interested in hacking cellular phone networks, and was in need for
specialized software that could help him do that. That led him to
Tsutomu Shimomura, a researcher working at the San Diego Supercomputer
Center, who was one of the leading researchers on the security of
cellular phone networks. He had the code that Mitnick wanted.</p>
<p>In 1994, Mitnick successfully launched an attack on Shimomura’s
computer, by exploiting the vulnerabilities in the TCP protocol and the
trusted relationship between two of Shimomura’s computers. The attack
triggered a dramatic showdown between the two people, and it eventually
led to the arrest of Mitnick. The showdown was turned into books and
Hollywood movies later. The attack is now known as the Mitnick attack,
which is a special type of TCP session hijacking.</p>
<p>The objective of this lab is to recreate the classic Mitnick attack, so
students can gain the first-hand experience on such an attack. We will
emulate the settings that was originally on Shimomura’s computers, and
then launch the Mitnick attack to create a forged TCP session between
two of Shimomura’s computers. If the attack is successful, we should be
able to run any command on Shimomura’s computer. This lab covers the
following topics:</p>
<ul class="simple">
<li>TCP session hijacking attack</li>
<li>TCP three-way handshake protocol</li>
<li>The Mitnick attack</li>
<li>Remote shell <code class="docutils literal notranslate"><span class="pre">rsh</span></code></li>
<li>Packet sniffing and spoofing</li>
</ul>
<p><strong>Readings and videos.</strong> Detailed coverage of the TCP session hijacking can be found in the
following:</p>
<ul class="simple">
<li>Chapter 16 of the SEED Book, Computer &amp; Internet Security: A Hands-on Approach, 2nd Edition,
by Wenliang Du. See details at <a class="reference external" href="https://www.handsonsecurity.net">https://www.handsonsecurity.net</a>.</li>
<li>Section 6 of the SEED Lecture, Internet Security: A Hands-on Approach, by Wenliang Du. See details
at <a class="reference external" href="https://www.handsonsecurity.net/video.html">https://www.handsonsecurity.net/video.html</a>.</li>
</ul>
<p><strong>Lab environment.</strong> This lab has been tested on the SEED Ubuntu 20.04 VM. You can download a pre-built
image from the SEED website, and run the SEED VM on your own computer. However, most of the SEED
labs can be conducted on the cloud, and you can follow our instruction to create a SEED VM on the cloud.</p>
</div>
<div class="section" id="how-the-mitnick-attack-works">
<h2>How the Mitnick Attack Works<a class="headerlink" href="#how-the-mitnick-attack-works" title="Permalink to this headline">¶</a></h2>
<p>The Mitnick attack is a special case of TCP session hijacking attacks.
Instead of hijacking an existing TCP connection between victims A and B,
the Mitnick attack creates a TCP connection between A and B first on
their behalf, and then naturally hijacks the connection.</p>
<p>In the actual Mitnick attack, host A was called X-Terminal, which was
the target. Mitnick wanted to log into X-Terminal and run his commands
on it. Host B was a trusted server, which was allowed to log into
X-Terminal without a password. In order to log into X-Terminal, Mitnick
had to impersonate the trusted server, so he did not need to provide any
password. Figure&nbsp;1 depicts the high-level picture
of the attack. There are four primary steps in this attack.</p>
<div class="figure align-center" id="id1">
<img alt="../../_images/mitnick_img1.png" src="../../_images/mitnick_img1.png" />
<p class="caption"><span class="caption-text">Figure 1: The illustration of the Mitnick Attack</span></p>
</div>
<p><strong>Step 1: Sequence number prediction.</strong> Before the attack, Mitnick needed to learn the pattern of the initial
sequence numbers (ISN) on X-terminal (in those days, ISNs were not
random). Mitnick sent SYN requests to X-terminal and received SYN+ACK
responses, then he sent RESET packet to X-Terminal, to clear the
half-open connection from X-Terminal’s queue (to prevent the queue from
being filled up). After repeating this for twenty times. He found there
was a pattern between two successive TCP ISNs. This allowed Mitnick to
predict ISNs, which was essential for the attack.</p>
<p><strong>Step 2: SYN flooding attack on the trusted server.</strong> To send a connection request from the trusted server to X-Terminal,
Mitnick needed to send out a SYN packet from the trusted server to
X-Terminal. X-Terminal would respond with a SYN+ACK packet, which was
sent to the trusted server. Since the trusted server did not actually
initiate the request, it would send a RESET packet to X-Terminal, asking
X-Terminal to stop the 3-way handshake. This behavior caused trouble to
the Mitnick attack.</p>
<p>To solve this problem. Mitnick had to silence the trusted server.
Therefore, before spoofing, Mitnick launched a SYN flooding attack on
the server. Back then, operating systems were far more vulnerable to the
SYN flooding attack. The attack could actually shut down the trusted
computer, completely silencing it.</p>
<p><strong>Step 3: Spoofing a TCP connection.</strong> Mitnick wanted to use <code class="docutils literal notranslate"><span class="pre">rsh</span></code>(remote shell) to run a backdoor command
on X-Terminal; once the backdoor was setup, he could then log into
X-Terminal. To run a remote shell on X-Terminal, Mitnick needed to pass
the authentication, i.e, he needed to have a valid account on X-Terminal
and know its password. Obviously, he did not have that.</p>
<p>Shimomura often needed to log into X-Terminal from the trusted server.
To avoid typing passwords each time, he added some information in the
<code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file on X-Terminal, so when he logged into X-Terminal from
the trusted server, no password would be asked. This was quite a common
practice back then. With this setup, without typing any password,
Shimomura could run a command on X-Terminal from the trusted server
using <code class="docutils literal notranslate"><span class="pre">rsh</span></code>, or run <code class="docutils literal notranslate"><span class="pre">rlogin</span></code> to log into X-Terminal. Mitnick wanted
to exploit this trusted relationship.</p>
<p>He needed to create a TCP connection between the trusted server and
X-Terminal, and then run <code class="docutils literal notranslate"><span class="pre">rsh</span></code> inside this connection. He first sent a
SYN request to X-Terminal, using the trusted server’s IP as the source
IP address. X-Terminal then sent a SYN+ACK response to the server. Since
the server had been shut down, it would not send RESET to close the
connection.</p>
<p>To complete the three-way handshake protocol, Mitnick needed to spoof an
ACK packet, which must acknowledge the sequence number in X-Terminal’s
SYN+ACK packet. Unfortunately, the SYN+ACK response only went to the
trusted server, not to Mitnick, he could not see the sequence number.
However, because of the prior investigation, Mitnick was able to predict
what this number was, so he was able to successfully spoof the ACK
response sent to X-Terminal to complete the TCP three-way handshake.</p>
<p><strong>Step 4: Running a remote shell.</strong> Using the established TCP connection between the trusted server and
X-Terminal, Mitnick could send a remote shell request to X-terminal,
asking it to run a command. Using this command, Mitnick wanted to create
a backdoor on X-Terminal so that he could get a shell on X-Terminal
anytime without repeating the attack.</p>
<p>All he needed to do was to add <code class="docutils literal notranslate"><span class="pre">&quot;+</span> <span class="pre">+&quot;</span></code> to the <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file on
X-Terminal. He could achieve that by executing the following command
using <code class="docutils literal notranslate"><span class="pre">rsh</span></code> on X-Terminal: “echo + + &gt; .rhosts”. Since <code class="docutils literal notranslate"><span class="pre">rsh</span></code> and
<code class="docutils literal notranslate"><span class="pre">rlogin</span></code> program used <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file for authentication, with this
addition, X-Terminal would trust every <code class="docutils literal notranslate"><span class="pre">rsh</span></code> and <code class="docutils literal notranslate"><span class="pre">rlogin</span></code> request
from anyone.</p>
</div>
<div class="section" id="lab-environment-setup-using-container">
<h2>Lab Environment Setup Using Container<a class="headerlink" href="#lab-environment-setup-using-container" title="Permalink to this headline">¶</a></h2>
<div class="section" id="container-setup">
<h3>Container Setup<a class="headerlink" href="#container-setup" title="Permalink to this headline">¶</a></h3>
<p>In this lab, we need three machines, one for X-Terminal, one for Trusted
Server, and the other for the attacker. In the real Mitnick attack, the
attacker machine is a remote machine. In this lab, for the sake of
simplicity, we put all these three machines on the same network.
Students can use three virtual machines for this lab, but it will be
much more convenient to use containers. The lab environment is depicted
Figure&nbsp;2.</p>
</div>
<div class="section" id="container-setup-and-commands">
<h3>Container Setup and Commands<a class="headerlink" href="#container-setup-and-commands" title="Permalink to this headline">¶</a></h3>
<p>Please download the <code class="docutils literal notranslate"><span class="pre">Labsetup.zip</span></code> file to your VM from the lab’s website, unzip it, enter the <code class="docutils literal notranslate"><span class="pre">Labsetup</span></code>
folder, and use the <code class="docutils literal notranslate"><span class="pre">docker-compose.yml</span></code> file to set up the lab environment. Detailed explanation of the
content in this file and all the involved <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> can be found from the user manual, which is linked
to the website of this lab. If this is the first time you set up a SEED lab environment using containers, it is
very important that you read the user manual.</p>
<p>In the following, we list some of the commonly used commands related to Docker and Compose. Since
we are going to use these commands very frequently, we have created aliases for them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file
(in our provided SEEDUbuntu 20.04 VM).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker-compose build    # Build the container image
$ docker-compose up       # Start the container
$ docker-compose down     # Shut down the container
</pre></div>
</div>
<div class="figure align-center" id="id2">
<img alt="../../_images/mitnick_img2.png" src="../../_images/mitnick_img2.png" />
<p class="caption"><span class="caption-text">Figure 2: Lab enviornment setup</span></p>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// Aliases for the Compose commands above
$ dcbuild                 # Alias for: docker-compose build
$ dcup                    # Alias for: docker-compose up
$ dcdown                  # Alias for: docker-compose down
</pre></div>
</div>
<p>All the containers will be running in the background. To run commands on a container, we often need
to get a shell on that container. We first need to use the “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">ps</span></code>” command to find out the ID of
the container, and then use “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">exec</span></code>” to start a shell on that container. We have created aliases for
them in the <code class="docutils literal notranslate"><span class="pre">.bashrc</span></code> file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ dockps // Alias for: docker ps --format &quot;{{.ID}} {{.Names}}&quot;
$ docksh &lt;id&gt; // Alias for: docker exec -it &lt;id&gt; /bin/bash

// The following example shows how to get a shell inside hostC
$ dockps
b1004832e275 hostA-10.9.0.5
0af4ea7a3e2e hostB-10.9.0.6
9652715c8e0a hostC-10.9.0.7

$ docksh 96
root@9652715c8e0a:/#

// Note: If a docker command requires a container ID, you do not need to
//       type the entire ID string. Typing the first few characters will
//       be sufficient, as long as they are unique among all the containers.
</pre></div>
</div>
<p>If you encounter problems when setting up the lab environment, please read the “Common Problems”
section of the manual for potential solutions.</p>
</div>
<div class="section" id="about-the-attacker-container">
<h3>About the Attacker Container<a class="headerlink" href="#about-the-attacker-container" title="Permalink to this headline">¶</a></h3>
<p>In this lab, we can either use the VM or the attacker container as the
attacker machine. If you look at the Docker Compose file, you will see
that the attacker container is configured differently from the other
containers. Here are the differences.</p>
<ul>
<li><p class="first"><em>Shared folder.</em> When we use the attacker container to launch
attacks, we need to put the attacking code inside the attacker
container.Code editing is more convenient inside the VM than in containers,
because we can use our favorite editors. In order for the VM and container to share files, we have
created a shared folder between the VM and the container using the Docker <code class="docutils literal notranslate"><span class="pre">volumes</span></code>. If you look
at the Docker Compose file, you will find out that we have added the following entry to some of the
containers. It indicates mounting the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code> folder on the host machine (i.e., the VM) to the
<code class="docutils literal notranslate"><span class="pre">/volumes</span></code> folder inside the container. We will write our code in the <code class="docutils literal notranslate"><span class="pre">./volumes</span></code> folder (on the
VM), so they can be used inside the containers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>volumes:
      ./volumes:/volumes
</pre></div>
</div>
</li>
<li><p class="first"><em>Host mode.</em> In this lab, the attacker needs to be able to sniff packets, but running sniffer programs
inside a container has problems, because a container is effectively attached to a virtual switch, so it
can only see its own traffic, and it is never going to see the packets among other containers. To solve
this problem, we use the <code class="docutils literal notranslate"><span class="pre">host</span></code> mode for the attacker container. This allows the attacker container to
see all the traffics. The following entry used on the attacker container:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>network_mode: host
</pre></div>
</div>
<p>When a container is in the <code class="docutils literal notranslate"><span class="pre">host</span></code> mode, it sees all the host’s network interfaces, and it even has the
same IP addresses as the host. Basically, it is put in the same network namespace as the host VM.
However, the container is still a separate machine, because its other namespaces are still different
from the host.</p>
</li>
<li><p class="first"><em>Privileged mode.</em>  To be able to modify kernel parameters at runtime (using <code class="docutils literal notranslate"><span class="pre">sysctl</span></code>), such as enabling
IP forwarding, a container needs to be privileged. This is achieved by including the following entry
in the Docker Compose file for the container.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>privileged: true
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="installing-the-rsh-program-no-action-is-needed">
<h3>Installing the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> program (no action is needed)<a class="headerlink" href="#installing-the-rsh-program-no-action-is-needed" title="Permalink to this headline">¶</a></h3>
<p>The remote shell <code class="docutils literal notranslate"><span class="pre">rsh</span></code> is a command line program that can execute
shell commands remotely. Although we will use <code class="docutils literal notranslate"><span class="pre">rsh</span></code> in this task, we
should know that <code class="docutils literal notranslate"><span class="pre">rsh</span></code> and <code class="docutils literal notranslate"><span class="pre">rlogin</span></code> programs are not secure, and
they are not used any more. They have been replaced by more secured
programs, such as <code class="docutils literal notranslate"><span class="pre">ssh</span></code>. That is why in the modern Linux operating
systems, the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> command is actually a symbolic link to the <code class="docutils literal notranslate"><span class="pre">ssh</span></code>
program.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls -al /etc/alternatives | grep rsh
lrwxrwxrwx   1 root root    12 Jul 25  2017 rsh -&gt; /usr/bin/ssh
</pre></div>
</div>
<p>To recreate the Mitnick attack, we need to install the unsecure version
of the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> program. Obviously, the old version of the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> no
longer works, but an open-source project re-implements the remote shell
clients and servers. It is called <code class="docutils literal notranslate"><span class="pre">rsh-redone</span></code>. We can use the
following commands to install <code class="docutils literal notranslate"><span class="pre">rsh</span></code> server and client. <strong>Note:</strong> The
<code class="docutils literal notranslate"><span class="pre">rsh</span></code> programs are already installed in the X-Terminal and Trusted
Server containers (see the <code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> inside the container image
folder).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo apt-get install rsh-redone-client
$ sudo apt-get install rsh-redone-server
</pre></div>
</div>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rsh</span></code> server program uses two files for authentication,
<code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> and <code class="docutils literal notranslate"><span class="pre">/etc/hosts.equiv</span></code>. Every time the server receives a
remote command request, it will check the <code class="docutils literal notranslate"><span class="pre">/etc/hosts.equiv</span></code>. If the
request comes from a hostname stored in the file, the server will accept
it without asking for passwords. If <code class="docutils literal notranslate"><span class="pre">/etc/hosts.equiv</span></code> does not exist
or do not have that hostname, <code class="docutils literal notranslate"><span class="pre">rsh</span></code> will check the <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file on
the user’s home directory.</p>
<p>Shimomura often needed to run remote commands on X-Terminal from the
trusted server. To avoid typing passwords, he created a <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file
on host X-Terminal and put the trusted server’s IP address into the
file. Note that the <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file must reside at the top level of a
user’s home directory and can be written <strong>only by the owner/user</strong>.</p>
<p>Please use the following commands on X-Terminal to set up the
<code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file. It should be noted when we get into a container, we
will be in the root account. In this lab, we need to switch to a normal
user account called seed, which is already created inside the container:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># su seed          &lt;- Switch to the seed account
$ cd               &lt;- Go to seed&#39;s home directory
$ touch .rhosts    &lt;- Create an empty file
$ echo [Server&#39;s IP address] &gt; .rhosts
$ chmod 644 .rhosts
</pre></div>
</div>
<p>To verify your configuration, try running the following command on the
trusted server.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># su seed          &lt;- Switch to the seed account
$ rsh [X-Terminal&#39;s IP] date
</pre></div>
</div>
<p>If the command prints the current date and time, your configuration is
working now. If you see “Authentication Failure”, something in your
setup may not be correct. One of the common mistakes is the permission
on the <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file: you should make sure it is only writable to the
owner.</p>
<p><strong>Allow all.</strong> To allow users to execute commands on X-Terminal from all IP addresses,
we just need to put two plus signs (<code class="docutils literal notranslate"><span class="pre">&quot;+</span> <span class="pre">+&quot;</span></code>) in the <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file.
This is very dangerous, and nobody should do that. But if you are an
attacker, this is a convenient way to set up a backdoor. As we have
mentioned before, this is what has been used in the Mitnick attack.</p>
</div>
</div>
<div class="section" id="task-1-simulated-syn-flooding">
<h2>Task 1: Simulated SYN flooding<a class="headerlink" href="#task-1-simulated-syn-flooding" title="Permalink to this headline">¶</a></h2>
<p>The operating systems at the time of the Mitnick Attack were vulnerable
to SYN flooding attacks, which could mute the target machine or even
shut it down. However, SYN flooding can no longer cause such a damage
for modern operating systems. We will simulate this effect.</p>
<p>We can manually stop the trusted server container, but that is not
enough. When X-Terminal receives a SYN packet from the trusted server,
it will respond with a SYN+ACK packet. Before sending out this packet,
it needs to know the MAC address of the trusted server. The ARP cache
will be checked first. If there is no entry for the trusted server,
X-Terminal will send out an ARP request packet to ask for the MAC
address. Since the trusted server has been muted, no one is going to
answer the ARP request, hence X-Terminal cannot send out the response.
As a result, the TCP connection will not be established.</p>
<p>In the real attack, the trusted server’s MAC address was actually in
X-Terminal’s ARP cache. Even if it was not, before silencing the trusted
server, we could simply spoof an ICMP echo request from the trusted
server to X-Terminal, that would trigger X-Terminal to reply to the
trusted server, and hence would get the trusted server’s MAC address,
and save it to the cache.</p>
<p>To simplify the task, before stopping the trusted server, we will simply
ping it from X-Terminal once, and then use the <code class="docutils literal notranslate"><span class="pre">arp</span></code> command to check
and make sure that the MAC address is in the cache. It should be noted
that cache entry may be deleted by the operating system if the OS fails
to reach a destination using the cached MAC address. To simply your
attack, you can run the following command on X-Terminal to permanently
add an entry to the ARP cache (it needs to run in the root account):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># arp -s [Server&#39;s IP] [Server&#39;s MAC]
</pre></div>
</div>
</div>
<div class="section" id="task-2-spoof-tcp-connections-and-rsh-sessions">
<h2>Task 2: Spoof TCP Connections and <code class="docutils literal notranslate"><span class="pre">rsh</span></code> Sessions<a class="headerlink" href="#task-2-spoof-tcp-connections-and-rsh-sessions" title="Permalink to this headline">¶</a></h2>
<p>Now that we have “brought down” the trusted server, we can impersonate
the trusted server, and try to launch a <code class="docutils literal notranslate"><span class="pre">rsh</span></code> session with X-Terminal.
Since <code class="docutils literal notranslate"><span class="pre">rsh</span></code> runs on top of TCP, we first need to establish a TCP
connection between the trusted server and X-Terminal, and then run the
<code class="docutils literal notranslate"><span class="pre">rsh</span></code> in this TCP connection.</p>
<p>One of the difficulties in the Mitnick attack is to predict the TCP
sequence numbers. It was possible back then when TCP sequence numbers
were not randomized. However, modern operating systems now randomize
their TCP sequence numbers (as a countermeasure against TCP session
hijacking attacks), so predicting the numbers becomes infeasible. To
simulate the situation of the original Mitnick attack, we allow students
to sniff packets, so they can get the sequence numbers, instead of
guessing them.</p>
<p><strong>Restriction.</strong> To simulate the original Mitnick attack as closely as we can, even
though students can sniff the TCP packets from X-Terminal, they cannot
use all the fields in captured packets, because in the real attacks,
Mitnick could not sniff packets. When students write their attack
programs, they can only use the following fields from the captured
packets. Penalty will be applied if other fields are used.</p>
<ul class="simple">
<li><strong>The TCP sequence number field</strong> (this does not include the
acknowledgment field).</li>
<li><strong>The TCP flag field</strong>. This allows us to know the types of the
captured TCP packets. In the actual Mitnick attack, Mitnick knew
exactly what type of packets were sent out by X-Terminal, because
they are part of the TCP three-way handshake protocol. We allow
students to use this field for task simplification.</li>
<li><strong>All the length fields</strong>, including IP header length, IP total
length, and TCP header length. These pieces of information are not
necessary for the attacks. In the actual Mitnick attack, Mitnick knew
exactly what their values are. We allow students to use these fields
for task simplification.</li>
</ul>
<p><strong>The behavior of ``rsh``.</strong> To create a spoofed <code class="docutils literal notranslate"><span class="pre">rsh</span></code> session between the trusted server and
X-Terminal, we need to understand the behavior of <code class="docutils literal notranslate"><span class="pre">rsh</span></code>. Let us start
a <code class="docutils literal notranslate"><span class="pre">rsh</span></code> session from Trusted Server to X-Terminal, and then use
Wireshark to capture the packets between them (note: we will run
Wireshark on the attacker VM; make sure to select the correct network
interface corresponding to the <code class="docutils literal notranslate"><span class="pre">10.9.0.0/24</span></code> network). We use the
following command to run the <code class="docutils literal notranslate"><span class="pre">date</span></code> command on Host B from Host A via
the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> remote shell.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>// On Trusted Server
$ rsh 10.9.0.5 date
</pre></div>
</div>
<p>The packet trace in this <code class="docutils literal notranslate"><span class="pre">rsh</span></code> session is shown in the following. Here
<code class="docutils literal notranslate"><span class="pre">10.9.0.6</span></code> is the Trusted Server’s IP address, and <code class="docutils literal notranslate"><span class="pre">10.9.0.5</span></code> is
X-Terminal’s IP address. If a packet does not carry any TCP data, the
length information (i.e. <code class="docutils literal notranslate"><span class="pre">Len=0</span></code>) is omitted. Below is Listing 1: Packet trace
of a rsh session.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># The first connection
   SRC IP    DEST IP   TCP Header
1  10.9.0.6  10.9.0.5  1023 -&gt; 514 [SYN] Seq=778933536
2  10.9.0.5  10.9.0.6  514 -&gt; 1023 [SYN,ACK] Seq=10879102 Ack=778933537
3  10.9.0.6  10.9.0.5  1023 -&gt; 514 [ACK] Seq=778933537 Ack=10879103
4  10.9.0.6  10.9.0.5  1023 -&gt; 514 [ACK] Seq=778933537 Ack=10879103 Len=20
                       RSH Session Establishment
                       Data: 1022\x00seed\x00seed\x00date\x00
5  10.9.0.5  10.9.0.6  514 -&gt; 1023 [ACK] Seq=10879103 Ack=778933557

# The second connection
6  10.9.0.5  10.9.0.6  1023 -&gt; 1022 [SYN] Seq=3920611526
7  10.9.0.6  10.9.0.5  1022 -&gt; 1023 [SYN,ACK] Seq=3958269143 Ack=3920611527
8  10.9.0.5  10.9.0.6  1023 -&gt; 1022 [ACK] Seq=3920611527 Ack=3958269144


# Going back to the first connection
9  10.9.0.5  10.9.0.6  514 -&gt; 1023 [ACK] Seq=10879103 Ack=778933557 Len=1
                       Data: \x00
10 10.9.0.6  10.9.0.5  1023 -&gt; 514 [ACK] Seq=778933557 Ack=10879104
11 10.9.0.5  10.9.0.6  514 -&gt; 1023 [ACK] Seq=10879104 Ack=778933557 Len=29
                       Data: Sun Feb 16 13:41:17 EST 2020
</pre></div>
</div>
<p>We can observe that a <code class="docutils literal notranslate"><span class="pre">rsh</span></code> session consists of two TCP connections.
The first connection is initiated by Host A (the client). An <code class="docutils literal notranslate"><span class="pre">rshd</span></code>
process on Host B is listening to connection requests at port 514.
Packets 1 to 3 are for the three-way handshake protocol. After the
connection has been established, the client send <code class="docutils literal notranslate"><span class="pre">rsh</span></code> data (including
user IDs and commands) to the Host B (Packet 4). The <code class="docutils literal notranslate"><span class="pre">rshd</span></code> process
will authenticate the user, and if the user is authenticated, <code class="docutils literal notranslate"><span class="pre">rshd</span></code>
initiates a separate TCP connection with the client.</p>
<p>The second connection is used for sending error messages. In the trace
above, since there was no error, the connection was never used, but the
connection must be successfully established, or <code class="docutils literal notranslate"><span class="pre">rshd</span></code> will not
continue. Packets 6 to 7 are for the three-way handshake protocol of the
second connection.</p>
<p>After the second connection has been established, Host B will send a
zero byte to the client (using the first connection), Host A will
acknowledge the packet. After that, <code class="docutils literal notranslate"><span class="pre">rshd</span></code> on Host B will run the
command sent by the client, and the output of the command will be sent
back to the client, all via the first connection. Students can use
Wireshark to capture a <code class="docutils literal notranslate"><span class="pre">rsh</span></code> session, and study its behaviors, before
launching the Mitnick attack. We divide the attack task into two
sub-tasks, each one focusing on one connection.</p>
<div class="section" id="task-2-1-spoof-the-first-tcp-connection">
<h3>Task 2.1: Spoof the First TCP Connection<a class="headerlink" href="#task-2-1-spoof-the-first-tcp-connection" title="Permalink to this headline">¶</a></h3>
<p>The first TCP connection is initiated by the attacker via a spoofed SYN
packet. As you can see in Figure&nbsp;3, after
X-Terminal receives the SYN packet, it will in turn send a SYN+ACK
packet to the trusted server. Since the server has been brought down, it
will not reset the connection. The attacker, which is on the same
network, can sniff the packet and get the sequence number.</p>
<p><strong>Step 1: Spoof a SYN packet.</strong> Students should write a program to spoof a SYN packet from the trusted
server to X-Terminal (see Packet 1 in Listing&nbsp;1). There are six standard TCP
code bits, and they can be set in the flag field of the TCP header. The
following code examples show how to set the flag field and how to check
whether certain bits are set in the flag field.</p>
<div class="figure align-center" id="id3">
<img alt="../../_images/mitnick_img3.png" src="../../_images/mitnick_img3.png" />
<p class="caption"><span class="caption-text">Figure 3: First Connection</span></p>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># &#39;U&#39;: URG bit
# &#39;A&#39;: ACK bit
# &#39;P&#39;: PSH bit
# &#39;R&#39;: RST bit
# &#39;S&#39;: SYN bit
# &#39;F&#39;: FIN bit

tcp = TCP()

# Set the SYN and ACK bits
tcp.flags = &quot;SA&quot;

# Check whether the SYN and ACK are the only bits set
if tcp.flags == &quot;SA&quot;:

# Check whether the SYN and ACK bits are set
if &#39;S&#39; in tcp.flags and &#39;A&#39; in tcp.flags:
</pre></div>
</div>
<p>It should be noted that the source port of the SYN packet must be from
port <code class="docutils literal notranslate"><span class="pre">1023</span></code>. If a different port is used, <code class="docutils literal notranslate"><span class="pre">rsh</span></code> will reset the
connection after the connection is established. If this step is
successful, from Wireshark, we should be able to see a SYN+ACK packet
coming out of X-Terminal (see Packet 2 in
Listing&nbsp;1).</p>
<p><strong>Step 2: Respond to the SYN+ACK packet.</strong> After X-Terminal sends out a SYN+ACK, the trusted server needs to send
out an ACK packet to complete the three-way handshake protocol. The
acknowledge number in the packet should be <code class="docutils literal notranslate"><span class="pre">S+1</span></code>, where <code class="docutils literal notranslate"><span class="pre">S</span></code> is the
sequence number contained in the SYN+ACK packet. See Packet 3 in
Listing&nbsp;1.</p>
<p>In the actual Mitnick attack, the attacker could not see the SYN+ACK
packet, because it was sent to the trusted server, not to the attacker.
That is why Mitnick had to guess the value of the sequence number. In
this lab, we allow students to get the sequence number via packet
sniffing.</p>
<p>Students need to write a sniff-and-spoof program using <code class="docutils literal notranslate"><span class="pre">Scapy</span></code> and run
it on the attacker’s machine. Here is a skeleton of a sniff-and-spoof
program that might be useful. Please make sure to follow the
restrictions described at the beginning of the section, or you will get
a penalty.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/python3
from scapy.all import *

x_ip      = &quot;10.9.0.5&quot;  # X-Terminal
x_port    = 514         # Port number used by X-Terminal

srv_ip    = &quot;10.9.0.6&quot;  # The trusted server
srv_port  = 1023        # Port number used by the trusted server

# Add 1 to the sequence number used in the spoofed SYN
seq_num     = 0x1000 + 1


def spoof(pkt):
  global seq_num   # We will update this global variable in the function

  old_ip  = pkt[IP]
  old_tcp = pkt[TCP]

  # Print out debugging information
  tcp_len = old_ip.len - old_ip.ihl*4 - old_tcp.dataofs*4  # TCP data length
  print(&quot;{}:{} -&gt; {}:{}  Flags={} Len={}&quot;.format(old_ip.src, old_tcp.sport,
                         old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))



  # Construct the IP header of the response
  ip = IP(src=srv_ip, dst=x_ip)

  # Check whether it is a SYN+ACK packet or not;
  #   if it is, spoof an ACK packet

  # ... Add code here ...

myFilter = &#39;tcp&#39;   # You need to make the filter more specific
sniff(iface=&#39;br-****&#39;, filter=myFilter, prn=spoof)
                  ^^-You need to set the correct value here.
</pre></div>
</div>
<p><strong>Step 3: Spoof the ``rsh`` data packet.</strong> Once the connection is established, the attacker needs to send <code class="docutils literal notranslate"><span class="pre">rsh</span></code>
data to X-Terminal. The structure of the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> data is shown below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[port number]\x00[uid_client]\x00[uid_server]\x00[your command]\x00
</pre></div>
</div>
<p>The data has four parts: a port number, client’s user ID, server’s user
ID, and a command. The port number will be used for the second
connection (see Task 2.2). Both client and server’s user ID is <code class="docutils literal notranslate"><span class="pre">seed</span></code>
in our container. The four fields are separated by a byte 0. Note that
there is also a byte 0 at the end of the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> data. An example is
given in the following. In this example, we tell X-Terminal that we are
going to listen on port 9090 for the second connection and the command
we want to run is <code class="docutils literal notranslate"><span class="pre">&quot;touch</span> <span class="pre">/tmp/xyz&quot;</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>data = &#39;9090\x00seed\x00seed\x00touch /tmp/xyz\x00&#39;
send(IP()/TCP()/data, verbose=0)
</pre></div>
</div>
<p>Students should modify the sniff-and-spoof program written in Step 2, so
an <code class="docutils literal notranslate"><span class="pre">rsh</span></code> data packet is sent to X-Terminal (see Packet 4 in
Listing&nbsp;1). If this step is successful,
from Wireshark, we can see that X-Terminal is going to initiate a TCP
connection to the trusted server’s port <code class="docutils literal notranslate"><span class="pre">9090</span></code>, which is the port
number specified in our <code class="docutils literal notranslate"><span class="pre">rsh</span></code> data.</p>
<p>In your report, please describe whether the <code class="docutils literal notranslate"><span class="pre">touch</span></code> command has been
executed on X-Terminal or not. Please also include snapshots of your
Wireshark.</p>
</div>
<div class="section" id="task-2-2-spoof-the-second-tcp-connection">
<h3>Task 2.2: Spoof the Second TCP Connection<a class="headerlink" href="#task-2-2-spoof-the-second-tcp-connection" title="Permalink to this headline">¶</a></h3>
<div class="figure align-center" id="id4">
<img alt="../../_images/mitnick_img4.png" src="../../_images/mitnick_img4.png" />
<p class="caption"><span class="caption-text">Figure 4: Second Connection</span></p>
</div>
<p>After the first connection has been established, X-Terminal will
initiate the second connection. This connection is used by <code class="docutils literal notranslate"><span class="pre">rshd</span></code> to
send out error messages. In our attack, we will not use this connection,
but if this connection is not established, <code class="docutils literal notranslate"><span class="pre">rshd</span></code> will stop without
executing our command. Therefore, we need to use spoofing to help
X-Terminal and the trusted server finish establishing this connection.
See Figure&nbsp;4.</p>
<p>Students need to write another sniff-and-spoof program, which sniffs the
TCP traffic going to the port 9090 of the trusted server (assuming
<code class="docutils literal notranslate"><span class="pre">9090</span></code> is used in Task 2.1). When it sees a SYN packet, it should
respond with a SYN+ACK packet. See Packet 7 in
Listing&nbsp;1 for an example.</p>
<p>If both connections have been successfully established, <code class="docutils literal notranslate"><span class="pre">rshd</span></code> will
execute the command contained in the <code class="docutils literal notranslate"><span class="pre">rsh</span></code> data packet. Please check
the <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> folder and see whether <code class="docutils literal notranslate"><span class="pre">/tmp/xyz</span></code> is created and whether
its timestamp matches the present time. Please include your evidence in
your report.</p>
</div>
</div>
<div class="section" id="task-3-set-up-a-backdoor">
<h2>Task 3: Set Up a Backdoor<a class="headerlink" href="#task-3-set-up-a-backdoor" title="Permalink to this headline">¶</a></h2>
<p>In Task 2, we only run a <code class="docutils literal notranslate"><span class="pre">touch</span></code> command in the attack to prove that
we can successfully run a command on X-Terminal. If we want to run more
commands later, we can always launch the same attack. That is quite
inconvenient.</p>
<p>Mitnick did plan to come back to X-Terminal. Instead of launching the
attack again and again, he planted a backdoor in X-Terminal after his
initial attack. This backdoor allowed him to log into X-Terminal
normally anytime he wanted, without typing any password. To achieve this
goal, as we have discussed in Section&nbsp;3.5,
all we need to do is to add the string <code class="docutils literal notranslate"><span class="pre">&quot;+</span> <span class="pre">+&quot;</span></code> to the <code class="docutils literal notranslate"><span class="pre">.rhosts</span></code> file
(in a single line). We can include the following command in our <code class="docutils literal notranslate"><span class="pre">rsh</span></code>
data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>echo + + &gt; .rhosts
</pre></div>
</div>
<p>Students should replace the <code class="docutils literal notranslate"><span class="pre">touch</span></code> command in Task 2 with the
<code class="docutils literal notranslate"><span class="pre">echo</span></code> command above, and then repeat the attack. If the attack
succeeds, the attacker should be able to remotely log into X-Terminal
using the following command, and no password is needed:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ rsh [X-Terminal&#39;s IP]
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">rsh</span></code> program may have not been installed on the attacker
container, but you can easily install it using the following commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># apt-get update &amp;&amp; apt-get -y install rsh-redone-client
</pre></div>
</div>
</div>
<div class="section" id="submission">
<h2>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h2>
<p>You need to submit a detailed lab report, with screenshots, to describe what you have done and what you
have observed. You also need to provide explanation to the observations that are interesting or surprising.
Please also list the important code snippets followed by explanation. Simply attaching code without any
explanation will not receive credits.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Sniffing_Spoofing.html" class="btn btn-neutral float-right" title="Packet Sniffing and Spoofing Lab" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="ICMP_Redirect.html" class="btn btn-neutral float-left" title="ICMP Redirect Attack Lab" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, NEXUS Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>